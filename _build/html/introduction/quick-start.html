

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Getting Started with DART &mdash; DART Documentation 9.9.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/logo-wordmark-light-dart.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="what-is-dart.html">What is DART?</a></li>
</ul>
<p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation/system-requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation/fortran-compiler.html">Fortran90 Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation/locating-netcdf-library.html">Locating NetCDF Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation/downloading-dart.html">Downloading DART</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation/compiling-dart.html">Compiling DART</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation/verifying-installation.html">Verifying Installation</a></li>
</ul>
<p class="caption"><span class="caption-text">Observations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../observations/background.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../observations/history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../observations/observation-quantities.html">Observation Quantities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../observations/observation-types.html">Observation Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../observations/complex-observations.html">Complex Observations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../observations/example-observation-definition.html">Example Observation Definition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../observations/observation-sequence-file.html">Observation Sequence File</a></li>
</ul>
<p class="caption"><span class="caption-text">Radiance Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../radiance-support/rttov.html">RTTOV</a></li>
</ul>
<p class="caption"><span class="caption-text">Education</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../education/dart-lab.html">DART LAB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../education/dart-tutorial.html">DART Tutorial</a></li>
</ul>
<p class="caption"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contributing/contributors-guide.html">Contributors’ Guide</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">DART Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Getting Started with DART</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/introduction/quick-start.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-started-with-dart">
<h1>Getting Started with DART<a class="headerlink" href="#getting-started-with-dart" title="Permalink to this headline">¶</a></h1>
<p>The Data Assimilation Research Testbed (DART) is an open-source, freely
available community facility for ensemble data assimilation (DA)
developed and maintained by the <a class="reference external" href="https://www.image.ucar.edu/DAReS/">Data Assimilation Research Section
(DAReS)</a> at the <a class="reference external" href="https://ncar.ucar.edu">National Center
for Atmospheric Research (NCAR)</a> and released
under the open-source <a class="reference external" href="https://www.apache.org/licenses/LICENSE-2.0">Apache License
v2.0</a>. DART provides
modelers, observational scientists, and geophysicists with powerful,
flexible DA tools that are easy to use and can be customized to support
efficient and reliable DA applications. DART is primarily oriented for
DA research but has also been used in operational settings. DART is a
software environment that makes it easy to explore a variety of data
assimilation methods and observations with different numerical models
and is designed to facilitate the combination of assimilation
algorithms, models, and real (as well as synthetic) observations to
allow increased understanding of all three. DART includes extensive
documentation, a comprehensive tutorial, and a variety of models and
observation sets that can be used to introduce new users or graduate
students to ensemble DA. DART also provides a framework for developing,
testing, and distributing advances in ensemble DA to a broad community
of users by removing the implementation-specific peculiarities of
one-off DA systems.</p>
<p>DART is intended for use by DA beginners as well as experts, students as
well as teachers, national labs and centers as well as university
research labs, and everything in between; thus, different users may have
different goals in “getting started.” We have therefore broken the
process into the following sections, each of which can be read
independently:</p>
<ul class="simple">
<li><p><a class="reference external" href="#QuickStart">Quick-start instructions for the impatient</a></p></li>
<li><p><a class="reference external" href="#DetailedSetup">More detailed DART setup instructions</a></p>
<ul>
<li><p><a class="reference external" href="#conventions">On conventions used within this document</a>.</p></li>
<li><p><a class="reference external" href="#system">Check your system requirements</a>.</p></li>
<li><p><a class="reference external" href="#fortran90">Determine which F90 compiler is available</a>.</p></li>
<li><p><a class="reference external" href="#netCDFlib">Determine the location of (or build) the netCDF
library</a>.</p></li>
<li><p><a class="reference external" href="#download">Download the DART software</a>.</p></li>
<li><p><a class="reference external" href="#testing">Building and testing DART</a>.</p></li>
<li><p><a class="reference external" href="#verify">Verifying the DART installation</a>.</p></li>
</ul>
</li>
<li><p><a class="reference external" href="#WhatIsDA">What is data assimilation?</a></p>
<ul>
<li><p><a class="reference external" href="#EnsDAIntro">Introduction to ensemble DA</a></p></li>
<li><p><a class="reference external" href="#Lorenz63">The Lorenz 63 model: what is it and why should we
care?</a></p></li>
<li><p><a class="reference external" href="#DAForLorenz63">Data assimilation in DART using the Lorenz 63
model</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#WhatIsDART">What is DART?</a></p>
<ul>
<li><p><a class="reference external" href="#whyDart">Why should I use DART for my project?</a></p></li>
<li><p><a class="reference external" href="#dartHistory">A brief history of DART</a></p></li>
<li><p><a class="reference external" href="#dartWorkflow">High-level DA workflows in DART</a></p></li>
<li><p><a class="reference external" href="#dartDesign">DART’s design philosophy</a></p></li>
<li><p><a class="reference external" href="#dartCapabilities">Important capabilities of DART</a></p></li>
<li><p><a class="reference external" href="#citeDart">How to cite DART</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#RunWithMyModel">How do I run DART with my model?</a></p>
<ul>
<li><p><cite>Required ``model_mod`</cite> routines &lt;#requiredRoutines&gt;`__</p></li>
<li><p><a class="reference external" href="#simpleModel">Suggestions for a “simple” model</a></p></li>
<li><p><a class="reference external" href="#complexModel">Suggestions for a “complex” model</a></p></li>
<li><p><cite>How to test your ``model_mod`</cite> routines &lt;#howToTestModelMod&gt;`__</p></li>
</ul>
</li>
<li><p><a class="reference external" href="#RunWithMyObs">How do I add my observations to DART?</a></p>
<ul>
<li><p><a class="reference external" href="#obsBackground">Background on DART observations</a></p></li>
<li><p><a class="reference external" href="#newQUANTITIES">Adding new observation quantities</a></p></li>
<li><p><a class="reference external" href="#newTYPES">Adding new observation types</a></p></li>
<li><p><a class="reference external" href="#simpleObs">Simple observation definitions</a></p></li>
<li><p><a class="reference external" href="#complexObs">Obs definitions for observations needing special
handling</a></p></li>
<li><p><a class="reference external" href="#exampleObsDef">Example observation definition</a></p></li>
<li><p><a class="reference external" href="#obsSeqFile">Observation sequence file</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#DartForEducation">How would I use DART for teaching students and/or
myself?</a></p>
<ul>
<li><p><a class="reference external" href="#dartTutorial">The DART tutorial</a></p></li>
<li><p><a class="reference external" href="#dartLab">DART_LAB</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#ContributeToDart">How can I contribute to DART?</a></p></li>
</ul>
<hr class="docutils" />
<div class="section" id="quick-start-instructions-for-the-impatient">
<h2>Quick-start instructions for the impatient<a class="headerlink" href="#quick-start-instructions-for-the-impatient" title="Permalink to this headline">¶</a></h2>
<p>This section details how to get started with DART as quickly as
possible. This section may be for you if you want to see that DART works
before spending a lot of time learning about the details. However, if
this level of detail is too sparse for you, or if you run into any
problems, please refer to <a class="reference external" href="#DetailedSetup">More detailed DART setup
instructions</a>.</p>
<p>The DART source code is distributed on the GitHub repository
<a class="reference external" href="https://github.com/NCAR/DART">NCAR/DART</a> with the documentation
served through GitHub Pages at <a class="reference external" href="https://dart.ucar.edu">https://dart.ucar.edu</a>.</p>
<p>Go to <a class="reference external" href="https://github.com/NCAR/DART">https://github.com/NCAR/DART</a> and clone the repository or get the
ZIP file according to your preference. Take note of the directory you
installed into, which is referred to as <em>DARTHOME</em> below.</p>
<dl class="field-list simple">
<dt class="field-odd">exclamation</dt>
<dd class="field-odd"><p><em>IMPORTANT</em>: If you are interested in contributing to</p>
</dd>
</dl>
<p>DART, see <a class="reference external" href="#ContributeToDart">How can I contribute to DART?</a> for more
information.</p>
<p>Your <code class="docutils literal notranslate"><span class="pre">DARTHOME</span></code> directory will now contain the latest release of DART.</p>
<p>Go into the <code class="docutils literal notranslate"><span class="pre">build_templates</span></code> subdirectory and copy over the closest
<code class="docutils literal notranslate"><span class="pre">mkmf.template.&lt;compiler</span> <span class="pre">system&gt;</span></code> file into <code class="docutils literal notranslate"><span class="pre">mkmf.template</span></code>.</p>
<p>Edit <code class="docutils literal notranslate"><span class="pre">mkmf.template</span></code> to set the <code class="docutils literal notranslate"><span class="pre">NETCDF</span></code> directory location if not
in <code class="docutils literal notranslate"><span class="pre">/usr/local</span></code> or comment it out and set <code class="docutils literal notranslate"><span class="pre">$NETCDF</span></code> in your
environment.</p>
<dl class="field-list simple">
<dt class="field-odd">warning</dt>
<dd class="field-odd"><p><em>WARNING</em>: Your netCDF library must have been compiled with</p>
</dd>
</dl>
<p>the same compiler (including version) that you will use to compile DART
and also must include the F90 interfaces. In practice this means that
even if you have a netCDF distribution on your system, you may need to
recompile netCDF in a separate location to match the compiler you will
use for DART.</p>
<p>If you are interested in running <em>bgrid_solo</em>, <em>cam-fv</em>, or testing the
<em>NCEP/prep_bufr</em> observation converter, you will need to download a
supplemental archive file. There are several large files that are needed
to run some of these DART tests and examples that are not included on
Github in order to keep the repository as small as possible. These files
are available at:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 9%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Release</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Filename</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“Manhattan”</p></td>
<td><p>189M</p></td>
<td><p><a class="reference external" href="https://www.image.ucar.edu/pub/DART/Release_datasets/Manhattan_large_files.tar.gz">Manhattan_large_files.tar.gz</a></p></td>
</tr>
<tr class="row-odd"><td><p>“wrf-chem.r13172”</p></td>
<td><p>141M</p></td>
<td><p><a class="reference external" href="https://www.image.ucar.edu/pub/DART/Release_datasets/wrf-chem.r13172_large_files.tar.gz">wrf-chem.r
13172_large_files.tar.gz</a></p></td>
</tr>
<tr class="row-even"><td><p>“Lanai”</p></td>
<td><p>158M</p></td>
<td><p><a class="reference external" href="https://www.image.ucar.edu/pub/DART/Release_datasets/Lanai_large_files.tar.gz">Lanai_large_files.tar.gz</a></p></td>
</tr>
<tr class="row-odd"><td><p>“Kodiak”</p></td>
<td><p>158M</p></td>
<td><p><a class="reference external" href="https://www.image.ucar.edu/pub/DART/Release_datasets/Kodiak_large_files.tar.gz">Kodiak_large_files.tar.gz</a></p></td>
</tr>
<tr class="row-even"><td><p>“Jamaica”</p></td>
<td><p>32M</p></td>
<td><p><a class="reference external" href="https://www.image.ucar.edu/pub/DART/Release_datasets/Jamaica_large_files.tar.gz">Jamaica_large_files.tar.gz</a></p></td>
</tr>
<tr class="row-odd"><td><p>“Hawaii”</p></td>
<td><p>32M</p></td>
<td><p><a class="reference external" href="https://www.image.ucar.edu/pub/DART/Release_datasets/Hawaii_large_files.tar.gz">Hawaii_large_files.tar.gz</a></p></td>
</tr>
</tbody>
</table>
<p>If so desired, download the appropriate tar file and untar it into your
<code class="docutils literal notranslate"><span class="pre">DARTHOME</span></code> directory. Ignore any warnings about</p>
<blockquote>
<div><p>tar: Ignoring unknown extended header keyword</p>
</div></blockquote>
<p>You are now ready to start building the DART code. Go into
<code class="docutils literal notranslate"><span class="pre">models/lorenz_63/work</span></code> and run <em>quickbuild.csh</em>.</p>
<blockquote>
<div><div class="line-block">
<div class="line">cd models/lorenz_63/work</div>
<div class="line">./quickbuild.csh</div>
</div>
</div></blockquote>
<p>If it compiles, <em>:tada:</em> If not, see the next section for more
information. Run this series of commands to do a very basic test:</p>
<blockquote>
<div><div class="line-block">
<div class="line">./perfect_model_obs</div>
<div class="line">./filter</div>
</div>
</div></blockquote>
<p>If that runs, <em>:tada:</em> again! Finally, if you have Matlab installed on
your system add ‘$DARTHOME/diagnostics/matlab’ to your matlab search
path with the command</p>
<blockquote>
<div><p>addpath(‘path_to_dart/diagnostics/matlab’,‘-BEGIN’)</p>
</div></blockquote>
<p>replacing <code class="docutils literal notranslate"><span class="pre">path_to_dart</span></code> with your actual DARTHOME installation
directory.</p>
<p>In Matlab, run the <code class="docutils literal notranslate"><span class="pre">plot_total_err</span></code> diagnostic script while in the
<code class="docutils literal notranslate"><span class="pre">models/lorenz_63/work</span></code> directory. If the output plots and looks
reasonable (error level stays around 2 and doesn’t grow unbounded)
you’re great! Congrats.</p>
<p>If you are planning to run one of the models that uses MPI and want to
use the Lorenz 63 model as a test, run <code class="docutils literal notranslate"><span class="pre">./quickbuild.csh</span> <span class="pre">-mpi</span></code>. It
will build filter and any other MPI-capable executables with MPI.</p>
<dl class="field-list simple">
<dt class="field-odd">warning</dt>
<dd class="field-odd"><p><em>WARNING</em>: The underlying compiler used by <em>mpif90</em> must match</p>
</dd>
</dl>
<p>the same compiler that you use for DART and netCDF.</p>
<p>If any of these steps fail or you don’t know how to do them, you can see
much more detailed instructions in the next section that hopefully
should get you over any bumps you encountered in the process.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a href="#id1"><span class="problematic" id="id2">`</span></a></p>
<p>D
e
t
a
i
l
e
d
S
e
t
u
p
&gt;
`
_
_</p>
</td>
</tr>
<tr class="row-even"><td><p>M
o
r
e
d
e
t
a
i
l
e
d
D
A
R
T
s
e
t
u
p
d
e
s
c
r
i
p
t
i
o
n</p></td>
</tr>
<tr class="row-odd"><td><p>t
o
p</p>
<p>t
o
p
&gt;
`
_
_
]</p>
</td>
</tr>
<tr class="row-even"><td><p>T
h
i
s
s
e
c
t
i
o
n
i
s
a
m
o
r
e
d
e
t
a
i
l
e
d
d
e
s
c
r
i
p
t
i
o
n
o
f
t
h
e
s
t
e
p
s
i
n
t
h
e
p
r
e
v
i
o
u
s
s
e
c
t
i
o
n
,
`
Q
u
i
c
k
-
s
t
a
r
t
i
n
s
t
r
u
c
t
i
o
n
s
f
o
r
t
h
e
i
m
p
a
t
i
e
n
t</p>
<p>Q
u
i
c
k
S
t
a
r
t
&gt;
`
_
_
.
I
n
p
a
r
t
i
c
u
l
a
r
,
y
o
u
c
a
n
r
e
f
e
r
t
o
t
h
e
s
e
i
n
s
t
r
u
c
t
i
o
n
s
i
f
a
n
y
t
h
i
n
g
i
n
t
h
e
p
r
e
v
i
o
u
s
s
e
c
t
i
o
n
f
a
i
l
e
d
o
r
i
f
y
o
u
w
a
n
t
a
m
o
r
e
c
o
m
p
l
e
t
e
p
i
c
t
u
r
e
o
f
h
o
w
D
A
R
T
i
s
c
o
n
f
i
g
u
r
e
d
.</p>
</td>
</tr>
<tr class="row-odd"><td><p>T
h
e
g
e
t
t
i
n
g
s
t
a
r
t
e
d
p
r
o
c
e
s
s
i
s
s
u
m
m
a
r
i
z
e
d
i
n
t
h
e
f
o
l
l
o
w
i
n
g
s
t
e
p
s
:</p></td>
</tr>
<tr class="row-even"><td><p>`
O
n
c
o
n
v
e
n
t
i
o
n
s
u
s
e
d
w
i
t
h
i
n
t
h
i
s
d
o
c
u
m
e
n
t</p>
<p>c
o
n
v
e
n
t
i
o
n
s
&gt;
`
_
_
.
1
.
`
C
h
e
c
k
y
o
u
r
s
y
s
t
e
m
r
e
q
u
i
r
e
m
e
n
t
s</p>
<p>s
y
s
t
e
m
&gt;
`
_
_
.
2
.
`
D
e
t
e
r
m
i
n
e
w
h
i
c
h
F
9
0
c
o
m
p
i
l
e
r
i
s
a
v
a
i
l
a
b
l
e</p>
<p>f
o
r
t
r
a
n
9
0
&gt;
`
_
_
.
3
.
`
D
e
t
e
r
m
i
n
e
t
h
e
l
o
c
a
t
i
o
n
o
f
(
o
r
b
u
i
l
d
)
t
h
e
n
e
t
C
D
F
l
i
b
r
a
r
y</p>
<p>n
e
t
C
D
F
l
i
b
&gt;
`
_
_
.
4
.
`
D
o
w
n
l
o
a
d
t
h
e
D
A
R
T
s
o
f
t
w
a
r
e</p>
<p>d
o
w
n
l
o
a
d
&gt;
`
_
_
.
5
.
`
M
o
d
i
f
y
c
e
r
t
a
i
n
D
A
R
T
f
i
l
e
s
t
o
r
e
f
l
e
c
t
t
h
e
a
v
a
i
l
a
b
l
e
F
9
0
c
o
m
p
i
l
e
r
a
n
d
l
o
c
a
t
i
o
n
o
f
t
h
e
a
p
p
r
o
p
r
i
a
t
e
l
i
b
r
a
r
i
e
s</p>
<p>c
u
s
t
o
m
i
z
a
t
i
o
n
s
&gt;
`
_
_
.
6
.
`
B
u
i
l
d
t
h
e
e
x
e
c
u
t
a
b
l
e
s</p>
<p>b
u
i
l
d
i
n
g
&gt;
`
_
_
.
7
.
`
V
e
r
i
f
y
t
h
e
D
A
R
T
i
n
s
t
a
l
l
a
t
i
o
n</p>
<p>v
e
r
i
f
y
&gt;
`
_
_
.</p>
</td>
</tr>
</tbody>
</table>
<div class="section" id="on-conventions-used-within-this-document">
<h3>On conventions used within this document<a class="headerlink" href="#on-conventions-used-within-this-document" title="Permalink to this headline">¶</a></h3>
<p>This getting started document is intended to be used as a reference by
users of different levels and backgrounds. By design, this page is
mostly “self-contained” as a single page so that users can navigate
through the document links without becoming lost. Some sections contain
helpful information, while others contain step-by-step instructions to
run programs or shell commands.</p>
<p>In order to make the tutorial-style sections more clear, the following
conventions are used within this document:</p>
<p>Commands to be <strong>typed at the command line</strong> will appear in
<em>blockquote</em>. For example:</p>
<blockquote>
<div><p>my_command.exe run_it.nml</p>
</div></blockquote>
<p>The <strong>contents of a file</strong> will be <em>enclosed in a box</em> as follows (for
some hypothetical namelist file):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="n">hypothetical_nml</span>
  <span class="n">obs_seq_in_file_name</span> <span class="o">=</span> <span class="s2">&quot;obs_seq.in&quot;</span><span class="p">,</span>
  <span class="n">obs_seq_out_file_name</span> <span class="o">=</span> <span class="s2">&quot;obs_seq.out&quot;</span><span class="p">,</span>
  <span class="n">init_time_days</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">init_time_seconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">output_interval</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&amp;</span><span class="n">end</span>
</pre></div>
</div>
<p>The <strong>names of files</strong> or environment variables will appear in a
<em>code-block</em> as in <code class="docutils literal notranslate"><span class="pre">filename</span></code>.</p>
<p>The <em>names of executables</em> will be italicized (although note that italic
will also be used for emphasis where there is no potential for
confusion).</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: “pro-tip” information to note will be written like this.</p>
</dd>
<dt class="field-even">exclamation</dt>
<dd class="field-even"><p><em>IMPORTANT</em>: important information will be written like</p>
</dd>
</dl>
<p>this.</p>
<p>written like this.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>`
&lt;#
sy
st
em
&gt;`
__</p></td>
</tr>
<tr class="row-even"><td><p>Sy
st
em
Re
qu
ir
em
en
ts</p></td>
</tr>
<tr class="row-odd"><td><p>T
he
DA
RT
so
ft
wa
re
is
in
te
nd
ed
to
c
om
pi
le
a
nd
r
un
on
ma
ny
d
if
fe
re
nt
Un
ix
/L
in
ux
o
pe
ra
ti
ng
s
ys
te
ms
wi
th
li
tt
le
to
no
c
ha
ng
e.
At
th
is
p
oi
nt
we
ha
ve
no
p
la
ns
to
po
rt
DA
RT
to
W
in
do
ws
m
ac
hi
ne
s,
al
th
ou
gh
W
in
do
ws
10
u
se
rs
m
ay
be
in
te
re
st
ed
in
t
he
fr
ee
<a href="#id3"><span class="problematic" id="id4">`</span></a>W
in
do
ws
S
ub
sy
st
em
F
or
L
in
ux</p>
<blockquote>
<div><p>&lt;</p>
</div></blockquote>
<p>ht
tp
s:
//
do
cs
.m
ic
ro
so
ft
.c
om
/e
n-
us
/w
in
do
ws
/w
sl
/a
bo
ut
&gt;`
__
w
hi
ch
al
lo
ws
de
ve
lo
pe
rs
to
“r
un
a
G
NU
/L
in
ux
e
nv
ir
on
me
nt
—
i
nc
lu
di
ng
mo
st
co
mm
an
d-
li
ne
to
ol
s,
ut
il
it
ie
s,
a
nd
ap
pl
ic
at
io
ns
—
di
re
ct
ly
on
Wi
nd
ow
s,
u
nm
od
if
ie
d,
w
it
ho
ut
t
he
ov
er
he
ad
of
a
v
ir
tu
al
ma
ch
in
e”
(s
ee
ht
tp
s:
//
do
cs
.m
ic
ro
so
ft
.c
om
/e
n-
us
/w
in
do
ws
/w
sl
/a
bo
ut
f
or
mo
re
de
ta
il
s)</p>
</td>
</tr>
<tr class="row-even"><td><p>:
wa
rn
in
g:
*
DI
SC
LA
IM
ER
:*
we
ha
ve
t
ri
ed
to
ma
ke
t
he
DA
RT
co
de
as
po
rt
ab
le
as
p
os
si
bl
e,
b
ut
we
do
n
ot
ha
ve
ac
ce
ss
to
a
ll
c
om
pi
le
rs
on
a
ll
pl
at
fo
rm
s,
so
u
nf
or
tu
na
te
ly
we
ca
nn
ot
g
ua
ra
nt
ee
th
at
t
he
co
de
wi
ll
wo
rk
c
or
re
ct
ly
on
yo
ur
pa
rt
ic
ul
ar
s
ys
te
m.
We
a
re
g
en
ui
ne
ly
in
te
re
st
ed
in
yo
ur
ex
pe
ri
en
ce
bu
il
di
ng
t
he
s
ys
te
m,
so
we
w
el
co
me
y
ou
to
se
nd
us
an
e
ma
il
wi
th
yo
ur
e
xp
er
ie
nc
es
at
d
ar
t
&#64;
uc
ar
 .
ed
u,
w
hi
ch
we
wi
ll
en
de
av
or
to
i
nc
or
po
ra
te
in
to
fu
tu
re
ve
rs
io
ns
of
th
is
gu
id
e.</p></td>
</tr>
<tr class="row-odd"><td><p>Mi
ni
ma
ll
y,
y
ou
wi
ll
n
ee
d:</p></td>
</tr>
<tr class="row-even"><td><p>1.
<a href="#id5"><span class="problematic" id="id6">`</span></a>a
F
or
tr
an
90
c
om
pi
le
r
&lt;#
fo
rt
ra
n9
0&gt;
<a href="#id7"><span class="problematic" id="id8">`</span></a>_
_,
2.
t
he
`
ne
tC
DF
l
ib
ra
ri
es</p>
<blockquote>
<div><p>&lt;</p>
</div></blockquote>
<p>ht
tp
:/
/w
ww
.u
ni
da
ta
.u
ca
r.
ed
u/
so
ft
wa
re
/n
et
cd
f/
&gt;`
__
b
ui
lt
wi
th
t
he
F
90
in
te
rf
ac
e,
3.
<em>p
er
l</em>
(
ju
st
a
bo
ut
a
ny
v
er
si
on
),
4.
an
e
nv
ir
on
me
nt
th
at
u
nd
er
st
an
ds
<em>c
sh
*,
*
tc
sh
*,
*
sh
*,
a
nd
*
ks
h</em>
5.
t
he
lo
ng
-l
iv
ed
Un
ix
b
ui
ld
to
ol
<em>m
ak
e</em>
6.
a
nd
up
to
1
Gb
of
di
sk
s
pa
ce
f
or
t
he
DA
RT
d
is
tr
ib
ut
io
n.</p>
</td>
</tr>
<tr class="row-odd"><td><p>H
is
to
ry
h
as
s
ho
wn
th
at
it
is
a
ve
ry
go
od
id
ea
to
re
mo
ve
t
he
s
ta
ck
a
nd
he
ap
li
mi
ts
in
yo
ur
ru
n-
ti
me
e
nv
ir
on
me
nt
wi
th
t
he
f
ol
lo
wi
ng
te
rm
in
al
c
om
ma
nd
s:</p></td>
</tr>
<tr class="row-even"><td><p>&gt;
l
im
it
s
ta
ck
si
ze
u
nl
im
it
ed
&gt;
l
im
it
da
ta
si
ze
u
nl
im
it
ed</p></td>
</tr>
<tr class="row-odd"><td><p>A
dd
it
io
na
ll
y,
t
he
f
ol
lo
wi
ng
t
oo
ls
ha
ve
pr
ov
en
to
be
<em>n
ic
e</em>
(b
ut
a
re
n
ot
re
qu
ir
ed
to
r
un
DA
RT
):</p></td>
</tr>
<tr class="row-even"><td><p>1.
`
nc
vi
ew</p>
<blockquote>
<div><p>&lt;</p>
</div></blockquote>
<p>ht
tp
:/
/m
et
eo
ra
.u
cs
d.
ed
u/
~p
ie
rc
e/
nc
vi
ew
_h
om
<a href="#id25"><span class="problematic" id="id26">e_</span></a>
pa
ge
.h
tm
l&gt;
<a href="#id9"><span class="problematic" id="id10">`</span></a>_
_:
a
g
re
at
vi
su
al
b
ro
ws
er
f
or
ne
tC
DF
fi
le
s.
2.
<a href="#id11"><span class="problematic" id="id12">`</span></a>t
he
ne
tC
DF
O
pe
ra
to
rs
(
NC
O)</p>
<blockquote>
<div><p>&lt;</p>
</div></blockquote>
<p>ht
tp
:/
/n
co
.s
ou
rc
ef
or
ge
.n
et
/&gt;
<a href="#id13"><span class="problematic" id="id14">`</span></a>_
_:
t
oo
ls
to
p
er
fo
rm
op
er
at
io
ns
on
ne
tC
DF
f
il
es
li
ke
co
nc
at
en
at
in
g,
sl
ic
in
g,
a
nd
di
ci
ng
3.
So
me
so
rt
of
M
PI
en
vi
ro
nm
en
t.
In
o
th
er
wo
rd
s,
DA
RT
do
es
n
ot
co
me
wi
th
<em>M
PI
CH
*,
*L
AM
-M
PI
*,
or
*O
pe
nM
PI
*</em>,
b
ut
ma
ny
u
se
rs
of
DA
RT
re
ly
on
t
he
se
M
PI
d
is
tr
ib
ut
io
ns
to
r
un
DA
RT
in
a
di
st
ri
bu
te
d-
me
mo
ry
pa
ra
ll
el
se
tt
in
g.
In
o
rd
er
to
u
se
M
PI
wi
th
D
AR
T,
pl
ea
se
r
ef
er
to
<a href="#id15"><span class="problematic" id="id16">`</span></a>t
he
DA
RT
M
PI
in
tr
od
uc
ti
on</p>
<blockquote>
<div><p>&lt;</p>
</div></blockquote>
<p>da
rt
_m
pi
.m
d&gt;
<a href="#id17"><span class="problematic" id="id18">`</span></a>_
_.
4.
If
y
ou
wa
nt
to
u
se
t
he
DA
RT
di
ag
no
st
ic
sc
ri
pt
s,
y
ou
wi
ll
ne
ed
a
b
as
ic
M
AT
LA
B®
i
ns
ta
ll
at
io
n.
No
ad
di
ti
on
al
t
oo
lb
ox
es
a
re
r
eq
ui
re
d,
a
nd
no
t
hi
rd
-p
ar
ty
t
oo
lb
ox
es
a
re
r
eq
ui
re
d.</p>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="requirements-a-fortran90-compiler">
<h3>Requirements: a Fortran90 compiler<a class="headerlink" href="#requirements-a-fortran90-compiler" title="Permalink to this headline">¶</a></h3>
<p>The DART software is written in standard Fortran 90, with no
compiler-specific extensions. It has been compiled and run with several
versions of each of the following: * <a class="reference external" href="http://gcc.gnu.org/fortran">GNU Fortran Compiler
(“gfortran”)</a> (free) * <a class="reference external" href="http://software.intel.com/en-us/intel-composer-xe">Intel Fortran
Compiler for Linux and
OSX</a> * <a class="reference external" href="http://www-01.ibm.com/software/awdtools/fortran/">IBM XL
Fortran Compiler</a>
* <a class="reference external" href="http://www.pgroup.com/">Portland Group Fortran Compiler</a> *
<a class="reference external" href="http://www.lahey.com/">Lahey Fortran Compiler</a> * <a class="reference external" href="https://www.nag.com/nag-compiler">NAG Fortran
compiler</a> * <a class="reference external" href="https://en.wikipedia.org/wiki/PathScale">PathScale Fortran
compiler</a></p>
<p>Since recompiling the code is a necessity to experiment with different
models, there are no DART binaries to distribute. If you are unfamiliar
with Fortran and/or wonder why we would choose this language, see <a class="reference external" href="#whyFortran">Why
Fortran?</a> for more information.</p>
</div>
<div class="section" id="requirements-the-netcdf-library">
<h3>Requirements: the netCDF library<a class="headerlink" href="#requirements-the-netcdf-library" title="Permalink to this headline">¶</a></h3>
<p>DART uses the <a class="reference external" href="https://www.unidata.ucar.edu/software/netcdf/">netCDF</a>
self-describing data format for storing the results of assimilation
experiments. These files have the extension <em>.nc</em> and can be read by a
number of standard data analysis tools. In particular, DART also makes
use of the F90 netCDF interface which is available through the
<code class="docutils literal notranslate"><span class="pre">netcdf.mod</span></code> and <code class="docutils literal notranslate"><span class="pre">typesizes.mod</span></code> modules and the <code class="docutils literal notranslate"><span class="pre">libnetcdf</span></code>
library. Depending on the version, the <code class="docutils literal notranslate"><span class="pre">libnetcdff</span></code> library is also
often required.</p>
<p>If the netCDF library does not exist on your system, you must build it
(as well as the F90 interface modules).</p>
<dl class="field-list simple">
<dt class="field-odd">warning</dt>
<dd class="field-odd"><p><em>WARNING</em>: You must build netCDF with the same compiler</p>
</dd>
</dl>
<p>(including version) you plan to use for compiling DART. In practice this
means that even if you have a netCDF distribution on your system, you
may need to recompile netCDF in a separate location to match the
compiler you will use for DART. The library and instructions for
building the library or installing from a package manager may be found
at the netCDF home page: <a class="reference external" href="https://www.unidata.ucar.edu/software/netcdf/">https://www.unidata.ucar.edu/software/netcdf/</a></p>
<dl class="field-list simple">
<dt class="field-odd">exclamation</dt>
<dd class="field-odd"><p><em>IMPORTANT</em>: the normal location for the netCDF Fortran</p>
</dd>
</dl>
<p>modules and libraries would be in the <code class="docutils literal notranslate"><span class="pre">include</span></code> and <code class="docutils literal notranslate"><span class="pre">lib</span></code>
subdirectories of the netCDF installation. However, different compilers
or package managers sometimes place the modules and/or libraries into
non-standard locations. It is required that both modules and the
libraries be present.</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE:</em> The location of the netCDF library, <code class="docutils literal notranslate"><span class="pre">libnetcdf.a</span></code>, and</p>
</dd>
</dl>
<p>the locations of both <code class="docutils literal notranslate"><span class="pre">netcdf.mod</span></code> and <code class="docutils literal notranslate"><span class="pre">typesizes.mod</span></code> will be
needed later. Depending on the version of netCDF and the build options
selected, the Fortran interface routines may be in a separate library
named <code class="docutils literal notranslate"><span class="pre">libnetcdff.a</span></code> (note the two F’s). In this case both libraries
are required to build executables.</p>
</div>
<div class="section" id="download-dart">
<h3>Download DART<a class="headerlink" href="#download-dart" title="Permalink to this headline">¶</a></h3>
<p>The DART source code is distributed on the GitHub repository
<a class="reference external" href="https://github.com/NCAR/DART">NCAR/DART</a> with the documentation
served through GitHub Pages at <a class="reference external" href="http://dart.ucar.edu">http://dart.ucar.edu</a>.</p>
<p>Go to <a class="reference external" href="https://github.com/NCAR/DART">https://github.com/NCAR/DART</a> and clone the repository or get the
ZIP file according to your preference. See the <a class="reference external" href="https://help.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository">github help page on
cloning</a>
for more information on how to clone a repository. Take note of the
directory you installed into, which is referred to as <em>DARTHOME</em> below.</p>
<dl class="field-list simple">
<dt class="field-odd">exclamation</dt>
<dd class="field-odd"><p><em>IMPORTANT</em>: If you are interested in contributing to</p>
</dd>
</dl>
<p>DART, see <a class="reference external" href="#ContributeToDart">How can I contribute to DART?</a> for more
information. In short, you will need to be familiar with the <a class="reference external" href="https://guides.github.com/introduction/flow/">GitHub
workflow</a>.</p>
<p>Unzip or clone the distribution in your desired directory, which we
refer to as “DARTHOME” in this document. Compiling the code in this tree
(as is usually the case) may require a large amount of additional disk
space (up to the 1 Gb required for DART), so be aware of any disk quota
restrictions before continuing.</p>
</div>
<div class="section" id="building-and-testing-dart">
<h3>Building and testing DART<a class="headerlink" href="#building-and-testing-dart" title="Permalink to this headline">¶</a></h3>
<p>Now that the DART code has been downloaded and the prerequisites have
been verified, you can now begin building and verifying the DART
installation.</p>
<div class="section" id="customizing-the-build-scripts-overview">
<h4>Customizing the build scripts — overview<a class="headerlink" href="#customizing-the-build-scripts-overview" title="Permalink to this headline">¶</a></h4>
<p>DART executable programs are constructed using two tools: <em>mkmf</em>, and
<em>make</em>. The <em>make</em> utility is a very commonly used tool that requires a
user-defined input file (a <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>) that records dependencies
between different source files. <em>make</em> then performs actions to the
source hierarchy, in order of dependence, when one or more of the source
files is modified. <em>mkmf</em> is a <em>perl</em> script that generates a <em>make</em>
input file (named <em>Makefile</em>) and an example namelist
<code class="docutils literal notranslate"><span class="pre">input.nml.&lt;program&gt;_default</span></code> with default values.</p>
<p><em>mkmf</em> (think <em>“make makefile”</em>) requires two separate input files. The
first is a template file which specifies the commands required for a
specific Fortran90 compiler and may also contain pointers to directories
containing pre- compiled utilities required by the DART system. <strong>This
template file will need to be modified to reflect your system as
detailed in the next section</strong>.</p>
<p>The second input file is a <code class="docutils literal notranslate"><span class="pre">path_names</span></code> file which is supplied by DART
and can be used without modification. An <em>mkmf</em> command is executed
which uses the <code class="docutils literal notranslate"><span class="pre">path_names</span></code> file and the mkmf template file to produce
a <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> which is subsequently used by the standard <em>make</em>
utility.</p>
<p>Shell scripts that execute the <em>mkmf</em> command for all standard DART
executables are provided with the standard DART distribution. For more
information on the <a class="reference external" href="https://github.com/NOAA-GFDL/mkmf">mkmf</a> tool
please see the <a class="reference external" href="https://extranet.gfdl.noaa.gov/~vb/mkmf.html">mkmf
documentation</a>.</p>
</div>
<div class="section" id="building-and-customizing-the-mkmf-template-file">
<h4>Building and Customizing the ‘mkmf.template’ file<a class="headerlink" href="#building-and-customizing-the-mkmf-template-file" title="Permalink to this headline">¶</a></h4>
<p>A series of templates for different compilers/architectures can be found
in the <em>DARTHOME/build_templates</em> directory and have names with
extensions that identify the compiler, the architecture, or both. This
is how you inform the build process of the specifics of your system.
<strong>Our intent is that you copy one that is similar to your system into
``DARTHOME/build_templates/mkmf.template`` and customize it.</strong> For the
discussion that follows, knowledge of the contents of one of these
templates (e.g. <code class="docutils literal notranslate"><span class="pre">DARTHOME/build_templates/mkmf.template.intel.linux</span></code>)
is needed. Note that only the LAST lines of the file are shown here. The
first portion of the file is a large comment block that provides
valuable advice on how to customize the <em>mkmf</em> template file if needed.</p>
<p>MPIFC = mpif90 MPILD = mpif90 FC = ifort LD = ifort NETCDF = /usr/local
INCS = -I<span class="math notranslate nohighlight">\({NETCDF}/include LIBS = -L\)</span>{NETCDF}/lib -lnetcdf
-lnetcdff FFLAGS = -O2 $(INCS) LDFLAGS = $(FFLAGS) $(LIBS)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 62%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>variable</p></th>
<th class="head"><p>value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>FC</p></td>
<td><p>the Fortran compiler</p></td>
</tr>
<tr class="row-odd"><td><p>LD</p></td>
<td><p>the name of the loader;
typically, the same as
the Fortran compiler</p></td>
</tr>
<tr class="row-even"><td><p>MPIFC</p></td>
<td><p>the MPI Fortran
compiler; see <a class="reference external" href="dart_mpi.md">the DART
MPI
intro
duction</a>
for more info</p></td>
</tr>
<tr class="row-odd"><td><p>MPILD</p></td>
<td><p>the MPI loader; see <a class="reference external" href="dart_mpi.md">the
DART MPI
intro
duction</a>
for more info</p></td>
</tr>
<tr class="row-even"><td><p>NETCDF</p></td>
<td><p>the location of your
root netCDF
installation, which is
assumed to contain
<code class="docutils literal notranslate"><span class="pre">netcdf.mod</span></code> and
<code class="docutils literal notranslate"><span class="pre">typesizes.mod</span></code> in the
include subdirectory.
Note that the value of
the NETCDF variable will
be used by the “INCS”
and “LIBS” variables.</p></td>
</tr>
<tr class="row-odd"><td><p>INCS</p></td>
<td><p>the includes passed to
the compiler during
compilation. Note you
may need to change this
if your netCDF includes
<code class="docutils literal notranslate"><span class="pre">netcdf.mod</span></code> and
<code class="docutils literal notranslate"><span class="pre">typesizes.mod</span></code> are
not in the standard
location under the
<code class="docutils literal notranslate"><span class="pre">include</span></code> subdirectory
of NETCDF.</p></td>
</tr>
<tr class="row-even"><td><p>LIBS</p></td>
<td><p>the libraries passed to
“FC” (or “MPIFC”) during
compilation. Note you
may need to change this
if the netCDF libraries
<code class="docutils literal notranslate"><span class="pre">libnetcdf</span></code> and
<code class="docutils literal notranslate"><span class="pre">libnetcdff</span></code> are not
in the standard location
under the “lib”
subdirectory of NETCDF.</p></td>
</tr>
<tr class="row-odd"><td><p>FFLAGS</p></td>
<td><p>the Fortran flags passed
to “FC” (or “MPIFC”)
during compilation.
There are often flags
used for optimized code
versus debugging code.
See your particular
compiler’s documentation
for more information.</p></td>
</tr>
<tr class="row-even"><td><p>LDFLAGS</p></td>
<td><p>the linker flags passed
to <em>LD</em> during
compilation. See your
particular linker’s
documentation for more
information.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="customizing-the-path-names-files">
<h4>Customizing the ‘<a href="#id27"><span class="problematic" id="id28">path_names_</span></a>*’ files<a class="headerlink" href="#customizing-the-path-names-files" title="Permalink to this headline">¶</a></h4>
<p>Several <code class="docutils literal notranslate"><span class="pre">path_names_*</span></code> files are provided in the “work” directory for
each specific model. In this case, the directory of interest is
<code class="docutils literal notranslate"><span class="pre">DARTHOME/models/lorenz_63/work</span></code> (see the next section). Since each
model comes with its own set of files, the <code class="docutils literal notranslate"><span class="pre">path_names_*</span></code> files
typically need no customization. However, modifying these files will be
required if you wish to add your model to DART. See <a class="reference external" href="#RunWithMyModel">How do I run DART
with my model?</a> for more information.</p>
</div>
</div>
<div class="section" id="building-the-lorenz-63-dart-project">
<h3>Building the Lorenz_63 DART project.<a class="headerlink" href="#building-the-lorenz-63-dart-project" title="Permalink to this headline">¶</a></h3>
<p>In order to get started with DART, here we use the Lorenz 63 model,
which is a simple ODE model with only three variables. DART supports
models with many orders of magnitude more variables than three, but if
you can compile and run the DART code for any ONE of the models, you
should be able to compile and run DART for ANY of the models. For
time-dependent filtering known as <strong>cycling</strong>, where observations are
iteratively assimilated at multiple time steps, DART requires the
ability to move the model state forward in time. For low-order models,
this may be possible with a Fortran function call, but for higher-order
models, this is typically done outside of DART’s execution control.
However, the assimilation itself is conducted the same way for <strong>all</strong>
models. For this reason, here we focus solely on the Lorenz 63 model. If
so desired, see <a class="reference external" href="#Lorenz63">The Lorenz 63 model: what is it and why should we
care?</a> for more information on this simple yet
surprisingly relevant model. See <a class="reference external" href="#dartWorkflow">A high-level workflow of DA in
DART</a> for further information regarding the DART
workflow if you prefer to do so before building the code.</p>
<p>There are seven separate, stand-alone programs that are typically
necessary for the end-to-end execution of a DART experiment; see below
or the <a class="reference external" href="#WhatIsDART">What is DART?</a> section for more information on
these programs and their interactions. All DART programs are compiled
the same way, and each model directory has a directory called <code class="docutils literal notranslate"><span class="pre">work</span></code>
that has the components necessary to build the executables.</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE:</em> some higher-order models have many more than seven</p>
</dd>
</dl>
<p>programs; for example, the Weather Research and Forecasting (WRF) model,
which is run operationally around the world to predict regional weather,
has 28 separate programs. Nonetheless, each of these programs are built
the same way.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">quickbuild.csh</span></code> in each directory builds all seven programs
necessary for Lorenz 63. Describing what the <code class="docutils literal notranslate"><span class="pre">quickbuild.csh</span></code> script
does is useful for understanding how to get started with DART.</p>
<p>The following shell commands show how to build two of these seven
programs for the lorenz_63 model: <em>preprocess</em> and <em>obs_diag</em>.
<em>preprocess</em> is a special program that needs to be built and run to
automatically generate Fortran code that is used by DART to support a
subset of observations - which are (potentially) different for every
model. Once <em>preprocess</em> has been run and the required Fortran code has
been generated, any of the other DART programs may be built in the same
way as <em>obs_diag</em> in this example. Thus, the following runs <em>mkmf</em> to
make a <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> for <em>preprocess</em>, makes the <em>preprocess</em> program,
runs <em>preprocess</em> to generate the Fortran observation code, runs <em>mkmf</em>
to make a <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> for <em>obs_diag</em>, then makes the <em>obs_diag</em>
program:</p>
<blockquote>
<div><div class="line-block">
<div class="line">cd DARTHOME/models/lorenz_63/work</div>
<div class="line">./mkmf_preprocess</div>
<div class="line">make</div>
<div class="line">./preprocess</div>
<div class="line">./mkmf_obs_diag</div>
<div class="line">make</div>
</div>
</div></blockquote>
<p>The remaining executables are built in the same fashion as <em>obs_diag</em>:
run the particular <em>mkmf</em> script to generate a Makefile, then execute
<em>make</em> to build the corresponding program.</p>
<p>Currently, DART executables are built in a <code class="docutils literal notranslate"><span class="pre">work</span></code> subdirectory under
the directory containing code for the given model. The Lorenz_63 model
has seven <code class="docutils literal notranslate"><span class="pre">mkmf_xxxxxx</span></code> files for the following programs:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Program</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="../../assimilation_code/programs/preprocess/preprocess.html">preproces
s</a></p></td>
<td><p>creates custom source code for
just the observations of interest</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="../../assimilation_code/programs/create_obs_sequence/create_obs_sequence.html">cre
ate_obs_sequence</a></p></td>
<td><p>specify a (set) of observation
characteristics taken by a
particular (set of) instruments</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="../../assimilation_code/programs/create_fixed_network_seq/create_fixed_network_seq.html">create_fixed_netwo
rk_seq</a></p></td>
<td><p>specify the temporal attributes
of the observation sets</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="../../assimilation_code/programs/perfect_model_obs/perfect_model_obs.html">perfect_model_obs</a></p></td>
<td><p>spinup and generate “true state”
for synthetic observation
experiments</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="../../assimilation_code/programs/filter/filter.html">filter</a></p></td>
<td><p>perform data assimilation
analysis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="../../assimilation_code/programs/obs_diag/threed_sphere/obs_diag.html">obs_diag</a></p></td>
<td><p>creates observation-space
diagnostic files in netCDF format
to support visualization and
quantification.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="../../assimilation_code/programs/obs_sequence_tool/obs_sequence_tool.html">obs_sequence_tool</a></p></td>
<td><p>manipulates observation sequence
files. This tool is not generally
required (particularly for
low-order models) but can be used
to combine observation sequences
or convert from ASCII to binary
or vice-versa. Since this is a
rather specialized routine, we
will not cover its use further in
this document.</p></td>
</tr>
</tbody>
</table>
<p>As mentioned above, <code class="docutils literal notranslate"><span class="pre">quickbuild.csh</span></code> is a script that will build every
executable in the directory. There is an optional argument that will
additionally build the MPI-enabled versions which will not be covered in
this set of instructions. See <a class="reference external" href="dart_mpi.md">The DART MPI
introduction</a> page for more information on using DART
with MPI.</p>
<p>Running <code class="docutils literal notranslate"><span class="pre">quickbuild.csh</span></code> will compile all the executables mentioned
above for the lorenz_63 model:</p>
<blockquote>
<div><div class="line-block">
<div class="line">cd DARTHOME/models/lorenz_63/work</div>
<div class="line">./quickbuild.csh</div>
</div>
</div></blockquote>
<p>The result (hopefully) is that seven executables now reside in your work
directory.</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: The most common problem is that the netCDF libraries</p>
</dd>
</dl>
<p>and/or include files were not found in the specified location(s). The
second most common problem is that the netCDF libraries were built with
a different compiler than the one used for DART. Find (or compile) a
compatible netCDF library, edit the
<code class="docutils literal notranslate"><span class="pre">DARTHOME/build_templates/mkmf.template</span></code> to point to the correct
locations of the includes and library files, recreate the
<code class="docutils literal notranslate"><span class="pre">Makefile</span></code>s, and try again.</p>
<p>` &lt;#runningSomething&gt;`__</p>
</div>
<div class="section" id="checking-the-build-running-something">
<h3>Checking the build — running something.<a class="headerlink" href="#checking-the-build-running-something" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DARTHOME/models/lorenz_63/work</span></code> directory is distributed with
input files ready to run a simple experiment: use 20 ensemble members to
assimilate observations “every 6 hours” for 50 days. Simply run the
programs <em>perfect_model_obs</em> and <em>filter</em> to generate the results to
compare against known results. Note that this section is not intended to
provide any details of why you are doing what you are doing - this is
sort of a “black-box” test. See <a class="reference external" href="#lorenz63">The Lorenz 63 model: what is it and why
should we care?</a> to see more about what this “physically”
means for this low-order model, and <a class="reference external" href="#DAForLorenz63">Data assimilation in DART using the
Lorenz 63 model</a> for a more in-depth view of this
process.</p>
<p>The Manhattan release uses netCDF files for the input/output file
formats. <em>ncgen</em> is a helpful tool to create netCDF files from an ASCII
representation and is part of any netCDF installation. The <em>lorenz_63</em>
<code class="docutils literal notranslate"><span class="pre">quickbuild.csh</span></code> script already runs this command, but it is repeated
here for clarity. Once the necessary netCDF input files are created from
the ASCII <code class="docutils literal notranslate"><span class="pre">.cdl</span></code> text files, run <em>perfect_model_obs</em> to generate the
“true state” and <em>filter</em> to run the data assimilation:</p>
<blockquote>
<div><div class="line-block">
<div class="line">ncgen -o perfect_input.nc perfect_input.cdl</div>
<div class="line">ncgen -o filter_input.nc filter_input.cdl</div>
<div class="line">./perfect_model_obs</div>
<div class="line">./filter</div>
</div>
</div></blockquote>
<p>There should now be the following output files:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>from executable
“perfect_model_obs”</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">perfect_output.nc</span></code></p></td>
<td><p>The last timestep of the model
state.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">true_state.nc</span></code></p></td>
<td><p>The model trajectory - the
<strong>truth</strong>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code></p></td>
<td><p>The observations that were
harvested as the true model was
advanced (and which will be
assimilated).</p></td>
</tr>
<tr class="row-odd"><td><p><strong>from executable “filter”</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">preassim.nc</span></code></p></td>
<td><p>The ensemble of model states just
before assimilation. This is the
<strong>prior</strong>. :dart: <em>NOTE</em>: this
file is a time series of the
prior model states at all times.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">filter_output.nc</span></code></p></td>
<td><p>The ensemble of model states
after assimilation. This is the
<strong>posterior</strong>. :dart: <em>NOTE</em>:
this file has only the final time
step of the posterior model
state.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">analysis.nc</span></code></p></td>
<td><p>The model trajectory of the
posterior.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">obs_seq.final</span></code></p></td>
<td><p>The observations and ensemble
estimates of the ‘observations’.</p></td>
</tr>
<tr class="row-even"><td><p><strong>from both</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">dart_log.out</span></code></p></td>
<td><p>The run-time log of the
experiment. This grows with each
execution and may safely be
deleted at any time.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dart_log.nml</span></code></p></td>
<td><p>A record of the input settings of
the experiment. This file may
safely be deleted at any time.</p></td>
</tr>
</tbody>
</table>
<p>Note that if you change the <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> namelist values controlling
inflation (increasing the ensemble spread) and file output, several
(perhaps many) more files may be created. The section <a class="reference external" href="#DAForLorenz63">Data assimilation
in DART using the Lorenz 63 model</a> below describes
how to make changes to the <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> file and rerun the filter
experiment.</p>
</div>
<div class="section" id="configuring-the-dart-diagnostic-tools-for-matlab">
<h3>Configuring the DART diagnostic tools for MATLAB®<a class="headerlink" href="#configuring-the-dart-diagnostic-tools-for-matlab" title="Permalink to this headline">¶</a></h3>
<p>The Manhattan release of DART uses native MATLAB netCDF support and no
longer requires any third-party toolboxes or built-in MATLAB toolboxes.
To allow your environment to seamlessly use the DART MATLAB functions,
your MATLABPATH must be set such that you have access to several DART
directories. At the MATLAB prompt, type the following (using the real
path to your DART installation):</p>
<blockquote>
<div><div class="line-block">
<div class="line">&gt;&gt; addpath(‘path_to_dart/diagnostics/matlab’,‘-BEGIN’)</div>
<div class="line">&gt;&gt; addpath(‘path_to_dart/docs/DART_LAB/matlab’,‘-BEGIN’)</div>
</div>
</div></blockquote>
<p>It is very convenient to put these lines in your <em>~/matlab/startup.m</em>
file so they are executed every time MATLAB starts up. DART provides an
example <code class="docutils literal notranslate"><span class="pre">diagnostics/matlab/startup.m</span></code> that you can use, which is
internally documented through file comments.</p>
<p>` &lt;#verify&gt;`__</p>
</div>
<div class="section" id="verifying-the-dart-installation-requires-matlab">
<h3>Verifying the DART installation (requires MATLAB®)<a class="headerlink" href="#verifying-the-dart-installation-requires-matlab" title="Permalink to this headline">¶</a></h3>
<p>The Lorenz model is notoriously sensitive to very small changes; in
fact, the story of Lorenz discovering this sensitivity is a classic in
the annals of the study of chaos, which in turn was instrumental in the
development of data assimilation as a field of study. See <a class="reference external" href="#Lorenz63">The Lorenz 63
model: what is it and why should we care?</a> or <a class="reference external" href="#WhatIsDA">What is
data assimilation?</a> for more information.</p>
<p>This sensitivity is of practical interest for verifying these results.
The initial conditions files and observations sequences are provided in
ASCII, which is portable across systems, but there may be some
machine-specific round-off error in the conversion from ASCII to machine
binary. As Lorenz 63 is such a nonlinear model, extremely small
differences in the initial conditions may eventually result in
noticeably different model trajectories. Even different compiler flags
may cause tiny differences that ultimately result in large differences.
Your results should start out looking VERY SIMILAR and may diverge with
time.</p>
<p>The simplest way to determine if the installation is successful is to
run some of the functions available in <code class="docutils literal notranslate"><span class="pre">DARTHOME/diagnostics/matlab/</span></code>.
Usually, we launch MATLAB from the <code class="docutils literal notranslate"><span class="pre">DARTHOME/models/lorenz_63/work</span></code>
directory and use the MATLAB <em>addpath</em> command to make the
<code class="docutils literal notranslate"><span class="pre">DARTHOME/matlab/</span></code> functions available for execution in any working
directory.</p>
<p>In the case of this Lorenz model, we know the “true” (by definition)
state of the model that is consistent with the observations, which was
generated by the <em>perfect_model_obs</em> program as described in <a class="reference external" href="#runningSomething">Checking
the build — running something</a>. The following
MATLAB scripts compare the ensemble members with the truth and can
calculate the error in the assimilation:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ cd DARTHOME/models/lorenz_63/work
$  matlab -nodesktop
(lots of startup messages I&#39;m skipping)

    [matlab_prompt] addpath ../../../diagnostics/matlab
    [matlab_prompt] plot_total_err
    Input name of true model trajectory file;
    (cr) for perfect_output.nc
    perfect_output.nc
    Input name of ensemble trajectory file;
    (cr) for preassim.nc
    preassim.nc
    Comparing true_state.nc and
              preassim.nc
    [matlab_prompt] plot_ens_time_series
    Input name of ensemble trajectory file;
    (cr) for preassim.nc

    Comparing true_state.nc and
              preassim.nc
    Using Variable state IDs 1  2  3

    pinfo =

      struct with fields:

                     model: &#39;Lorenz_63&#39;
                   def_var: &#39;state&#39;
            num_state_vars: 1
                num_copies: 20
           num_ens_members: 20
          ensemble_indices: [1 2 3 ... 18 19 20]
             min_state_var: 1
             max_state_var: 3
            def_state_vars: [1 2 3]
                     fname: &#39;preassim.nc&#39;
                truth_file: &#39;true_state.nc&#39;
                diagn_file: &#39;preassim.nc&#39;
                truth_time: [1 200]
                diagn_time: [1 200]
                      vars: {&#39;state&#39;}
                      time: [200x1 double]
        time_series_length: 200
                       var: &#39;state&#39;
                  var_inds: [1 2 3]
</pre></div>
</div>
<p>From the above <em>plot_ens_time_series</em> graphic, you can see the
individual green ensemble members becoming more constrained with less
spread as time evolves. If your figures look similar to these, you
should feel confident that everything is working as intended. Don’t miss
the opportunity to rotate the “butterfly” plot for that classic chaos
theory experience (perhaps while saying, “life, uh, finds a way”).</p>
<p>Congratulations! You have now successfully configured DART and are ready
to begin the next phase of your interaction with DART. You may wish to
learn more about:</p>
<ul class="simple">
<li><p><a class="reference external" href="#WhatIsDA">What is data assimilation?</a> — a brief introduction to
ensemble data assimilation. This section includes more information
about the Lorenz 63 model and how to configure the <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> file
to play with DA experiments in DART using the Lorenz 63 model.</p></li>
<li><p><a class="reference external" href="#WhatIsDART">What is DART?</a> — This section includes more
information about DART and a basic flow chart of the overall DART
workflow.</p></li>
<li><p><a class="reference external" href="#RunWithMyModel">How do I run DART with my model?</a></p></li>
<li><p><a class="reference external" href="#RunWithMyObs">How do I add my observations to DART?</a></p></li>
<li><p><a class="reference external" href="#DartForEducation">How would I use DART for teaching students and/or
myself?</a></p></li>
<li><p><a class="reference external" href="#ContributeToDart">How can I contribute to DART?</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>REQUEST:</em> In the case that the above instructions had one or</p>
</dd>
</dl>
<p>more issues that either did not work for you as intended or were
confusing, please contact the DART software development team at dart &#64;
ucar .edu . We value your input to make getting started as smooth as
possible for new DART users!</p>
</div>
</div>
<div class="section" id="what-is-data-assimilation">
<h2>What is data assimilation?<a class="headerlink" href="#what-is-data-assimilation" title="Permalink to this headline">¶</a></h2>
<p>As some users may be unfamiliar with data assimilation and/or appreciate
a brief refresher, in this section we provide a (very) basic
introduction to the subject. For additional information, see the section
on <a class="reference external" href="#DartForEducation">How would I use DART for teaching students and/or
myself?</a>.</p>
<p>Included in this section are the subsections:</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="#EnsDAIntro">Introduction to ensemble DA</a> - a brief introduction
to the main concepts of DA</p></li>
<li><p><a class="reference external" href="#Lorenz63">The Lorenz 63 model: what is it and why should we
care?</a> - more information about the Lorenz 63 model and
its far-reaching consequences, and</p></li>
<li><p><a class="reference external" href="#DAForLorenz63">Data assimilation in DART using the Lorenz 63
model</a> - an expanded introduction to DA in DART
that opens up the “black box” of the Lorenz 63 model</p></li>
</ol>
<p>` &lt;#EnsDAIntro&gt;`__</p>
<div class="section" id="introduction-to-ensemble-da">
<h3>Introduction to ensemble DA<a class="headerlink" href="#introduction-to-ensemble-da" title="Permalink to this headline">¶</a></h3>
<p>Data assimilation is a powerful and widely used computational technique
that has many application areas throughout mathematics and science. At a
very high level, data assimilation refers to the process of merging
prior <em>forecasts</em> with new <em>observations</em>, creating a new analysis that
is an “optimal” blending of the two by taking into account their
relative uncertainties.</p>
<p>The following animated graphic describes the data assimilation process
at a high level:</p>
<p>Shown here are three ensemble members, each of which gives a different
initial prediction at the time <em>t</em><em>k</em>. Moving these predictions
forward in time to <em>t</em><em>k</em>+1 will give a new forecast distribution
called a <em>prior</em>. Suppose at this time there is also an observation,
which will have some uncertainty due to instrument noise, etc. Mapping
each of the ensemble members to the observations with a function <em>h</em> and
applying <strong>Bayes’ rule</strong> will generate an update to the prior
distribution, called here the <em>state increment</em>. Adding the state
increment to the ensemble members will give the new <em>analysis</em> (also
known as the <em>posterior</em>) at time <em>t</em><em>k</em>+1. This process can then
be repeated for each set of observations as many times as necessary.</p>
<p>Expanding on this somewhat, let’s call the <em>i</em>th ensemble member
<strong>x</strong>i at the time step we are working on. In the above graphic, there
were three ensemble members, but in general there are usually many more,
typically in the range of 20-1000 depending on the application. Each
member <strong>x</strong>i can have <em>n</em> components which together make up the
<strong>model state</strong>. Each member contains all the variables you want to find
the best fit for at a particular time. These variables are usually
physically meaningful quantities; for example, this might include the 3D
values of water vapor, temperature, wind speed, etc. for an atmospheric
model. These values are expected to be advanced forward in time by a
model, which is why they are called the “model state.”</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: we view the “model state” as the minimum amount of</p>
</dd>
</dl>
<p>information necessary to restart the model for a new forecast.</p>
<p>At any particular time step there may be <em>m</em> <strong>observations</strong> available.
These observations are assumed to relate to the model state and provide
“real world” checks against the model forecast. A “forward operator,”
represented in the above diagram by <em>h</em>, is a relationship that computes
what an observation is most likely to be given a model state. In other
words, <em>h</em> maps between <strong>x</strong>i and <strong>y</strong>j, giving the “expected
observation” of the <em>j</em>th observation given the <em>i</em>th ensemble
member. An observation may be of the same quantity as one found in the
model state at a particular location, in which case the <em>h</em> function
mapping them is trivial and the comparison is simple. The vector <strong>y</strong>
may also contain more complex derived functions of the state <strong>x</strong> (for
example radar observations of precipitation), in which case the <em>h</em>
function that models this mapping between <strong>x</strong> (in this example
precipitation) and <strong>y</strong> (in this example radar returns) may be an
algorithm that is quite complicated.</p>
<p>In practice, observations are never 100% reliable. The observations
themselves will have some uncertainty for example arising from
instrument noise. The instrument noise error variances are typically
published by the instrument manufacturer, and these observation errors
are usually assumed to be independent as true instrument “noise” should
not be correlated in time or space. Furthermore, since models have a
finite resolution (i.e. they are “fuzzy”), there is almost always an
error that arises when comparing the model to the observations. This is
called the <strong>representativeness error</strong>. Put together, the potential
“likelihood” of the possible values of the observation forms the
<strong>observational error distribution</strong> in the above graphic.</p>
<p>Finally, note that in real-world applications there are typically many
fewer observations than state variables, i.e. <em>m</em> is typically <strong>much
much less</strong> than <em>n</em>. In practice this means that the observations alone
cannot be relied upon to predict the model state; the ensemble approach
with Bayes’ rule is necessary.</p>
<p>DART makes it easy to find the optimal solution to the above problem
using an ensemble filter algorithm (the most typically used algorithm is
the <strong>Ensemble Adjustment Kalman Filter</strong>; see <a class="reference external" href="#dartCapabilities">Important capabilities
of DART</a> for more information). The user specifies
which state variables make up the <strong>x</strong> ensemble vectors, which
observations make up the <strong>y</strong> vector, and the observation error
variances. The ensemble of model states is assumed to be representative
of the uncertainty/spread in the model state. Finally, the user tells
DART how to advance the model from one forecast to the next. Once DART
has this information, it can proceed with optimally blending the
observations and model forecasts — in other words, performing data
assimilation.</p>
<p>The spread of the <strong>ensemble</strong> informs DART of the <strong>uncertainty</strong> in
the model state. This allows for as rich, complex, and meaningful
relationships as the data contained within the ensemble itself. By
default, no implicit assumptions about the relative uncertainties are
required, as the data can speak for itself. Areas of large uncertainty
will naturally have large spread, as the ensemble members will contain
very different values at those locations, while areas of low uncertainty
will naturally have low spread due to the ensemble having relatively
similar values at those locations. Furthermore, relationships in space
and between variables can also be meaningfully derived. Of course this
means that the quality of the ensemble is crucial to the success of the
DA process, as uncertainty can only be accurately quantified if the
ensemble is representative of the “true” uncertainty inherent in the
system. Due to the fact that a relatively small number of ensemble
members are typically used, estimated correlations between two distant
locations may become unreliable due to sampling error. Thus, various
techniques such as <strong>covariance localization</strong> may be employed to
improve the quality of estimated relationships and increase skill in
prediction. Furthermore, the ensemble spread may sometimes be deemed
“too small” or “too large” by various criteria, in which case a
multiplicative or additive <strong>inflation</strong> or <strong>deflation</strong>, respectively,
may be applied. In practice the ensemble method is usually far more
accurate and less error-prone than the main alternative of manually
specifying uncertainty by some manually-designed algorithm, and it is
certainly less labor-intensive to develop.</p>
<p>This was a brief introduction to the important concepts of DA. For more
information, see <a class="reference external" href="#DartForEducation">How would I use DART for teaching students and/or
myself?</a>.</p>
<p>In the next section, details of the Lorenz 63 model are provided to give
a more concrete illustration of the DA process.</p>
</div>
<div class="section" id="the-lorenz-63-model-what-is-it-and-why-should-we-care">
<h3>The Lorenz 63 model: what is it and why should we care?<a class="headerlink" href="#the-lorenz-63-model-what-is-it-and-why-should-we-care" title="Permalink to this headline">¶</a></h3>
<p>In this section we present additional detail about the Lorenz 63 model.
As we previously treated this model as a black box, this section will
provide background on this highly relevant chaotic system for the
purpose of deepening understanding of DART and DA in general.</p>
<p>In 1963, Edward Lorenz developed a simplified 3-variable model to
investigate atmospheric convection. By making several simplifications to
the Boussinesq approximation, the Lorenz model was derived for a single
thin layer of fluid uniformly heated from below and cooled from above.
The <a class="reference external" href="https://journals.ametsoc.org/doi/pdf/10.1175/1520-0469%281963%29020%3C0130%3ADNF%3E2.0.CO%3B2">original
paper</a>
(Lorenz, E. N. 1963. Deterministic nonperiodic flow. <em>J. Atmos.
Sci.</em> <strong>20</strong>, 130-141.) has been cited over 20,000 times. The relatively
simple — yet nonlinear — system of ordinary differential equations
(ODEs) is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="s1">&#39; = sigma*(Y-X)</span>
<span class="n">Y</span><span class="s1">&#39; = -XZ + rX - Y</span>
<span class="n">Z</span><span class="s1">&#39; =  XY - bZ</span>
</pre></div>
</div>
<p>where the left-hand sides of the equations are derivatives with respect
to time. Here, <code class="docutils literal notranslate"><span class="pre">X</span></code> is proportional to the rate of convection, <code class="docutils literal notranslate"><span class="pre">Y</span></code> is
related to the horizontal temperature variation, and <code class="docutils literal notranslate"><span class="pre">Z</span></code> is the
vertical temperature variation. There are three constant parameters:
<code class="docutils literal notranslate"><span class="pre">sigma</span></code> relates to the Prandtl number, <code class="docutils literal notranslate"><span class="pre">r</span></code> to the Rayleigh number,
and <code class="docutils literal notranslate"><span class="pre">b</span></code> to the physical dimensions of the layer. Note that <code class="docutils literal notranslate"><span class="pre">Y'</span></code> and
<code class="docutils literal notranslate"><span class="pre">Z'</span></code> each have a nonlinear term (<code class="docutils literal notranslate"><span class="pre">-XZ</span></code> and <code class="docutils literal notranslate"><span class="pre">XY</span></code>, respectively).</p>
<p>The numerical investigation of the <strong>chaos</strong> arising from this system of
ODEs unexpectedly launched a revolution in our understanding of nature
and lead to numerous mathematical and scientific breakthroughs. While
the chaotic nature of certain systems such as the three-body problem had
been investigated previously, it was the electronic computer, which
could compute thousands of calculations per second, that allowed these
ideas to be formalized. In particular, Lorenz’s model made it clear for
the first time how an infinitesimally small change in the initial
conditions could end up having a huge impact on the final results in
certain situations. Lorenz discussed the strange behavior of this model
in <a class="reference external" href="https://uwapress.uw.edu/book/9780295975146/the-essence-of-chaos/">The Essence of Chaos, University of Washington Press,
1995</a>:</p>
<blockquote>
<div><p>At one point I decided to repeat some of the computations in order
to examine what was happening in greater detail. I stopped the
computer, typed in a line of numbers that it had printed out a
while earlier, and set it running again. I went down the hall for
a cup of coffee and returned after about an hour, during which the
computer had simulated about two months of weather. The numbers
being printed out were nothing like the old ones. I immediately
suspected a weak vacuum tube or some other computer trouble, which
was not uncommon, but before calling for service I decided to see
just where the mistake had occurred, knowing that this could speed
up the servicing process. Instead of a sudden break, I found that
the new values at first repeated the old ones, but soon afterward
had differed by one and then several units in the last decimal
place. … The numbers I had typed in were not the exact original
numbers, but were the rounded-off values that appeared in the
original printout. The initial round-off errors were the culprits;
they were steadily amplifying until they dominated the solution.
In today’s terminology, there was chaos.</p>
</div></blockquote>
<p>Lorenz discovered that even in a model with just three variables, a very
small change in the initial conditions (in this case, the numbers he
typed back into the computer, which were very slightly different from
the original numbers) could cause the entire large-scale behavior to
change. Lorenz’s discovery has many important practical implications:</p>
<ol class="arabic simple">
<li><p>If tiny changes can grow to dominate a system, it is no longer
possible to find the one set of “perfect” initial conditions and hope
to allow the system to run forever with perfect forecasts. Instead,
forecasting chaotic systems must be approached <strong>statistically</strong>.</p></li>
<li><p>There is a practical limit of predictability inherent in chaotic
systems. In other words, the nonlinear dynamics of a chaotic model
are inherently difficult to predict. Multiple evaluations (an
<strong>ensemble</strong>) can be run with different plausible initial conditions
to quantify this error growth.</p></li>
<li><p>In order to forecast chaotic systems effectively, periodic
observations of the state are required to effectively guide the
forecast and narrow the uncertainty. Since in real-world applications
observations are almost always sparse compared to the number of state
variables, merging observations and forecasts (i.e. <strong>data
assimilation</strong>) is required to effectively forecast chaotic systems.</p></li>
</ol>
<p>While Lorenz 63 is a simple example of a chaotic system, there are many
other chaotic systems of real practical interest in areas such as
weather prediction, climate, oceanography, hydrology, ecology, biology,
… the list goes on and on. In short, while the Lorenz model is a simple
problem that can easily run even on the most meager of computers today,
it is representative of the same problem of predictability that can be
found throughout science. DART supports the investigation of forecasting
chaotic systems in <em>any</em> field where periodic observations can be used
to constrain the uncertainty using an ensemble.</p>
<p>` &lt;#DAForLorenz63&gt;`__</p>
</div>
<div class="section" id="data-assimilation-in-dart-using-the-lorenz-63-model">
<h3>Data assimilation in DART using the Lorenz 63 model<a class="headerlink" href="#data-assimilation-in-dart-using-the-lorenz-63-model" title="Permalink to this headline">¶</a></h3>
<p>In this section we open the “black box” of the Lorenz model that was
previously used in <a class="reference external" href="#QuickStart">Quick-start instructions for the
impatient</a> and <a class="reference external" href="#DetailedSetup">More detailed DART setup
instructions</a>. This section assumes you have
successfully run the Lorenz 63 model with the example observation files
that were distributed with the DART repository. In this section you will
learn in more detail how DART interacts with the Lorenz 63 model to
perform data assimilation.</p>
<div class="section" id="the-input-nml-namelist">
<h4>The input.nml namelist<a class="headerlink" href="#the-input-nml-namelist" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">DARTHOME/models/lorenz_63/work/input.nml</span></code> file is the Lorenz
model <em>namelist</em>, which is a standard Fortran method for passing
parameters from a text file into a program without needing to recompile.
There are many sections within this file that drive the behavior of DART
while using the Lorenz 63 model for assimilation. Within <code class="docutils literal notranslate"><span class="pre">input.nml</span></code>,
there is a section called <em>model_nml</em>, which contains the model-specific
parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="n">model_nml</span>
   <span class="n">sigma</span>  <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
   <span class="n">r</span>      <span class="o">=</span> <span class="mf">28.0</span><span class="p">,</span>
   <span class="n">b</span>      <span class="o">=</span> <span class="mf">2.6666666666667</span><span class="p">,</span>
   <span class="n">deltat</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
   <span class="n">time_step_days</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">time_step_seconds</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
   <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;RK2&#39;</span>
   <span class="o">/</span>
</pre></div>
</div>
<p>Here, you can see the values for the parameters <code class="docutils literal notranslate"><span class="pre">sigma</span></code>, <code class="docutils literal notranslate"><span class="pre">r</span></code>, and
<code class="docutils literal notranslate"><span class="pre">b</span></code> that were discussed in the previous section. These are the
original values Lorenz used in the 1963 paper to create the classic
butterfly attractor.</p>
</div>
<div class="section" id="the-lorenz-63-model-code">
<h4>The Lorenz 63 model code<a class="headerlink" href="#the-lorenz-63-model-code" title="Permalink to this headline">¶</a></h4>
<p>The Lorenz 63 model code, which is under
<code class="docutils literal notranslate"><span class="pre">DARTHOME/models/lorenz_63/model_mod.f90</span></code>, contains the lines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>subroutine comp_dt(x, dt)

real(r8), intent( in) ::  x(:)
real(r8), intent(out) :: dt(:)

! compute the lorenz model dt from standard equations

dt(1) = sigma * (x(2) - x(1))
dt(2) = -x(1)*x(3) + r*x(1) - x(2)
dt(3) = x(1)*x(2) - b*x(3)

end subroutine comp_dt
</pre></div>
</div>
<p>which directly translates the above ODE into Fortran.</p>
<p>Note that the routine <code class="docutils literal notranslate"><span class="pre">comp_dt</span></code> does not explicitly depend on the time
variable, only on the state variables (i.e. the Lorenz 63 model is time
invariant).</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: By default, the <code class="docutils literal notranslate"><span class="pre">model_mod.f90</span></code> follows the Lorenz 63</p>
</dd>
</dl>
<p>paper to use the Runge-Kutta 2 scheme (otherwise known as RK2 or the
midpoint scheme) to advance the model.</p>
<p>Since the Lorenz 63 model is time invariant, the RK2 code to advance the
ODE in time can be written as follows, again following the Lorenz 63
paper, for a <code class="docutils literal notranslate"><span class="pre">fract</span></code> fraction of a time-step (typically equal to 1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>!------------------------------------------------------------------
!&gt; does single time step advance for lorenz convective 3 variable model
!&gt; using two step rk time step

subroutine adv_single(x, fract)

real(r8), intent(inout) :: x(:)
real(r8), intent(in)    :: fract

real(r8) :: x1(3), x2(3), dx(3)

call comp_dt(x, dx)            !  compute the first intermediate step
x1 = x + fract * deltat * dx

call comp_dt(x1, dx)           !  compute the second intermediate step
x2 = x1 + fract * deltat * dx

!  new value for x is average of original value and second intermediate

x = (x + x2) / 2.0_r8

end subroutine adv_single
</pre></div>
</div>
<p>Together, these two code blocks describe how the Lorenz 63 model is
advanced in time. You will see how DART uses this functionality shortly.</p>
</div>
<div class="section" id="the-model-time-step-and-length-of-the-data-assimilation">
<h4>The model time step and length of the data assimilation<a class="headerlink" href="#the-model-time-step-and-length-of-the-data-assimilation" title="Permalink to this headline">¶</a></h4>
<p>In the original Lorenz 63 paper, the model is run for 50 “days” using a
non-dimensional time-step of 0.01, which is reproduced in the namelist
above. This time-step was assumed equal to 3600 seconds, or one hour, in
dimensional time. This is also set in the namelist above. The Lorenz 63
model observation file included with the DART repository uses
observations of all three state variables every six hours (so every six
model steps) to conduct the assimilation.</p>
<p>If you were previously able to run the Matlab diagnostic scripts, you
may have noticed that the butterfly attractor for the included example
does not look as smooth as might be desired:</p>
<p>This is because the model output was only saved once every six “hours”
at the observation times. As an exercise, let’s make a nicer-looking
plot using the computational power available today, which even on the
most humble of computers is many times greater than what Lorenz had in
1963. Let’s change Lorenz’s classic experiment to the following:</p>
<ol class="arabic simple">
<li><p>Make the non-dimensional timestep 0.001, a factor of 10 smaller,
which will correspond to a dimensional timestep of 360 seconds (6
minutes). This smaller time-step will lead to a smoother model
trajectory.</p></li>
<li><p>Keep the original ratio of time steps to observations included in the
DART repository of assimilating observations every six time steps,
meaning we now need observations every 36 minutes.</p></li>
</ol>
<p>Therefore, in order to conduct our new experiment, we will need to
regenerate the DART observation sequence files.</p>
<p>To change the time-step, change the <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> file in
<code class="docutils literal notranslate"><span class="pre">DARTHOME/models/lorenz_63/work</span></code> to the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="n">model_nml</span>
   <span class="n">sigma</span>  <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
   <span class="n">r</span>      <span class="o">=</span> <span class="mf">28.0</span><span class="p">,</span>
   <span class="n">b</span>      <span class="o">=</span> <span class="mf">2.6666666666667</span><span class="p">,</span>
   <span class="n">deltat</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
   <span class="n">time_step_days</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
   <span class="n">time_step_seconds</span> <span class="o">=</span> <span class="mi">360</span>
   <span class="o">/</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: the changes are to <code class="docutils literal notranslate"><span class="pre">deltat</span></code> and <code class="docutils literal notranslate"><span class="pre">time_step_seconds</span></code>.</p>
</dd>
<dt class="field-even">dart</dt>
<dd class="field-even"><p><em>NOTE</em>: we do not need to recompile the DART code as the purpose</p>
</dd>
</dl>
<p>of namelist files is to pass run-time parameters to a Fortran program
without recompilation.</p>
</div>
<div class="section" id="updating-the-observation-sequence">
<h4>Updating the observation sequence<a class="headerlink" href="#updating-the-observation-sequence" title="Permalink to this headline">¶</a></h4>
<p>Let’s now regenerate the DART observation files with the updated
timestep and observation ratio. In a typical large-scale application,
the user will provide observations to DART in a standardized format
called the <em>Observation Sequence</em> file. Since there are no real
observations of the Lorenz 63 system, we must create our own synthetic
observations - which may be done using <em>create_obs_sequence</em>,
<em>create_fixed_network_seq</em>, and <em>perfect_model_obs</em> programs; each of
which we will explain below. These helpful interactive programs are
included with DART to generate these observation sequence files for
typical research or education-oriented experiments. In such setups,
observations (with noise added) will be generated at regular intervals
from a model “truth”. This “truth” will only be available to the
experiment through the noisy observations but can later be used for
comparison purposes. The number of steps necessary for the ensemble
members to reach the true model state’s “attractor” can be investigated
and, for example, compared between different DA methods. This is an
example of an “OSSE” — see <a class="reference external" href="#dartWorkflow">High-level DA workflows in
DART</a> for more information.</p>
<p>The three programs used in this example to create an observation
sequence again are <em>create_obs_sequence</em>, <em>create_fixed_network_seq</em>,
and <em>perfect_model_obs</em>. <em>create_obs_sequence</em> creates a template for
the observations, <em>create_fixed_network_seq</em> repeats that template at
multiple times, and finally <em>perfect_model_obs</em> harvests the observation
values. These programs have many additional capabilities; if interested,
see the corresponding program’s documentation.</p>
<p>Let’s now run the DART program <em>create_obs_sequence</em> to create the
observation template that we will later replicate in time:</p>
<blockquote>
<div><p># Make sure you are in the DARTHOME/models/lorenz_63/work directory
./create_obs_sequence</p>
</div></blockquote>
<p>The program <em>create_obs_sequence</em> will ask for the number of
observations. Since we plan to have 3 observations at each time step
(one for each of the state variables), input <strong>3</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_nml_output</span> <span class="n">Echo</span> <span class="n">NML</span> <span class="n">values</span> <span class="n">to</span> <span class="n">log</span> <span class="n">file</span> <span class="n">only</span>

<span class="o">--------------------------------------------------------</span>
<span class="o">--------------</span> <span class="n">ASSIMILATE_THESE_OBS_TYPES</span> <span class="o">--------------</span>
  <span class="n">RAW_STATE_VARIABLE</span>
<span class="o">--------------------------------------------------------</span>
<span class="o">--------------</span> <span class="n">EVALUATE_THESE_OBS_TYPES</span>   <span class="o">--------------</span>
  <span class="n">none</span>
<span class="o">--------------------------------------------------------</span>
<span class="o">----------</span> <span class="n">USE_PRECOMPUTED_FO_OBS_TYPES</span>   <span class="o">--------------</span>
  <span class="n">none</span>
<span class="o">--------------------------------------------------------</span>

<span class="n">Input</span> <span class="n">upper</span> <span class="n">bound</span> <span class="n">on</span> <span class="n">number</span> <span class="n">of</span> <span class="n">observations</span> <span class="ow">in</span> <span class="n">sequence</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>For this experimental setup, we will not have any additional copies of
the data, nor will we have any quality control fields. So use <strong>0</strong> for
both.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span> <span class="n">number</span> <span class="n">of</span> <span class="n">copies</span> <span class="n">of</span> <span class="n">data</span> <span class="p">(</span><span class="mi">0</span> <span class="k">for</span> <span class="n">just</span> <span class="n">a</span> <span class="n">definition</span><span class="p">)</span>
<span class="mi">0</span>
<span class="n">Input</span> <span class="n">number</span> <span class="n">of</span> <span class="n">quality</span> <span class="n">control</span> <span class="n">values</span> <span class="n">per</span> <span class="n">field</span> <span class="p">(</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">greater</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>We now will setup each of the three observations. The program asks to
enter -1 if there are no additional observations, so input anything else
instead (<strong>1</strong> below). Then enter <strong>-1</strong>, <strong>-2</strong>, and <strong>-3</strong> in sequence
for the state variable index (the observation here is just the values of
the state variable). Use <strong>0 0</strong> for the time (we will setup a regularly
repeating observation after we finish this), and <strong>8</strong> for the error
variance for each observation.</p>
<p>Finally, after inputting press enter to use the default output file
<code class="docutils literal notranslate"><span class="pre">set_def.out</span></code>.</p>
<p>Input your values as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">input</span> <span class="n">a</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">no</span> <span class="n">more</span> <span class="n">obs</span>
<span class="mi">1</span>
    <span class="n">Input</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">state</span> <span class="n">variable</span> <span class="n">index</span> <span class="k">for</span> <span class="n">identity</span> <span class="n">observations</span>
    <span class="n">OR</span> <span class="nb">input</span> <span class="n">the</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="n">observation</span> <span class="n">kind</span> <span class="kn">from</span> <span class="nn">table</span> <span class="n">below</span><span class="p">:</span>
    <span class="n">OR</span> <span class="nb">input</span> <span class="n">the</span> <span class="n">integer</span> <span class="n">index</span><span class="p">,</span> <span class="n">BUT</span> <span class="n">see</span> <span class="n">documentation</span><span class="o">...</span>
               <span class="mi">1</span> <span class="n">RAW_STATE_VARIABLE</span>
<span class="o">-</span><span class="mi">1</span>
<span class="nb">input</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">days</span> <span class="ow">and</span> <span class="n">seconds</span> <span class="p">(</span><span class="k">as</span> <span class="n">integers</span><span class="p">)</span>
<span class="mi">0</span> <span class="mi">0</span>
<span class="n">Input</span> <span class="n">the</span> <span class="n">error</span> <span class="n">variance</span> <span class="k">for</span> <span class="n">this</span> <span class="n">observation</span> <span class="n">definition</span>
<span class="mi">8</span>
<span class="nb">input</span> <span class="n">a</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">no</span> <span class="n">more</span> <span class="n">obs</span>
<span class="mi">1</span>
    <span class="n">Input</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">state</span> <span class="n">variable</span> <span class="n">index</span> <span class="k">for</span> <span class="n">identity</span> <span class="n">observations</span>
    <span class="n">OR</span> <span class="nb">input</span> <span class="n">the</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="n">observation</span> <span class="n">kind</span> <span class="kn">from</span> <span class="nn">table</span> <span class="n">below</span><span class="p">:</span>
    <span class="n">OR</span> <span class="nb">input</span> <span class="n">the</span> <span class="n">integer</span> <span class="n">index</span><span class="p">,</span> <span class="n">BUT</span> <span class="n">see</span> <span class="n">documentation</span><span class="o">...</span>
               <span class="mi">1</span> <span class="n">RAW_STATE_VARIABLE</span>
<span class="o">-</span><span class="mi">2</span>
<span class="nb">input</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">days</span> <span class="ow">and</span> <span class="n">seconds</span> <span class="p">(</span><span class="k">as</span> <span class="n">integers</span><span class="p">)</span>
<span class="mi">0</span> <span class="mi">0</span>
<span class="n">Input</span> <span class="n">the</span> <span class="n">error</span> <span class="n">variance</span> <span class="k">for</span> <span class="n">this</span> <span class="n">observation</span> <span class="n">definition</span>
<span class="mi">8</span>
<span class="nb">input</span> <span class="n">a</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">no</span> <span class="n">more</span> <span class="n">obs</span>
<span class="mi">1</span>
    <span class="n">Input</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">state</span> <span class="n">variable</span> <span class="n">index</span> <span class="k">for</span> <span class="n">identity</span> <span class="n">observations</span>
    <span class="n">OR</span> <span class="nb">input</span> <span class="n">the</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="n">observation</span> <span class="n">kind</span> <span class="kn">from</span> <span class="nn">table</span> <span class="n">below</span><span class="p">:</span>
    <span class="n">OR</span> <span class="nb">input</span> <span class="n">the</span> <span class="n">integer</span> <span class="n">index</span><span class="p">,</span> <span class="n">BUT</span> <span class="n">see</span> <span class="n">documentation</span><span class="o">...</span>
               <span class="mi">1</span> <span class="n">RAW_STATE_VARIABLE</span>
<span class="o">-</span><span class="mi">3</span>
<span class="nb">input</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">days</span> <span class="ow">and</span> <span class="n">seconds</span> <span class="p">(</span><span class="k">as</span> <span class="n">integers</span><span class="p">)</span>
<span class="mi">0</span> <span class="mi">0</span>
<span class="n">Input</span> <span class="n">the</span> <span class="n">error</span> <span class="n">variance</span> <span class="k">for</span> <span class="n">this</span> <span class="n">observation</span> <span class="n">definition</span>
<span class="mi">8</span>
<span class="n">Input</span> <span class="n">filename</span> <span class="k">for</span> <span class="n">sequence</span> <span class="p">(</span><span class="o">&lt;</span><span class="k">return</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">set_def</span><span class="o">.</span><span class="n">out</span> <span class="p">)</span>

<span class="n">write_obs_seq</span>  <span class="n">opening</span> <span class="n">formatted</span> <span class="n">observation</span> <span class="n">sequence</span> <span class="n">file</span> <span class="s2">&quot;set_def.out&quot;</span>
<span class="n">write_obs_seq</span>  <span class="n">closed</span> <span class="n">observation</span> <span class="n">sequence</span> <span class="n">file</span> <span class="s2">&quot;set_def.out&quot;</span>
<span class="n">create_obs_sequence</span> <span class="n">Finished</span> <span class="n">successfully</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="creating-a-regular-sequence-of-observations">
<h4>Creating a regular sequence of observations<a class="headerlink" href="#creating-a-regular-sequence-of-observations" title="Permalink to this headline">¶</a></h4>
<p>We will now utilize another DART program that takes this <code class="docutils literal notranslate"><span class="pre">set_def.out</span></code>
file as input. The interactive program <code class="docutils literal notranslate"><span class="pre">create_fixed_network_seq</span></code> is a
helper tool that can be used to generate a DART observation sequence
file made of a set of regularly repeating observations.</p>
<blockquote>
<div><p># Make sure you are in the DARTHOME/models/lorenz_63/work directory
./create_fixed_network_seq</p>
</div></blockquote>
<p>We want to use the default <code class="docutils literal notranslate"><span class="pre">set_def.out</span></code> file, so press return. We
also want a regularly repeating time sequence, so input <strong>1</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_nml_output</span> <span class="n">Echo</span> <span class="n">NML</span> <span class="n">values</span> <span class="n">to</span> <span class="n">log</span> <span class="n">file</span> <span class="n">only</span>

<span class="o">--------------------------------------------------------</span>
<span class="o">--------------</span> <span class="n">ASSIMILATE_THESE_OBS_TYPES</span> <span class="o">--------------</span>
  <span class="n">RAW_STATE_VARIABLE</span>
<span class="o">--------------------------------------------------------</span>
<span class="o">--------------</span> <span class="n">EVALUATE_THESE_OBS_TYPES</span>   <span class="o">--------------</span>
  <span class="n">none</span>
<span class="o">--------------------------------------------------------</span>
<span class="o">----------</span> <span class="n">USE_PRECOMPUTED_FO_OBS_TYPES</span>   <span class="o">--------------</span>
  <span class="n">none</span>
<span class="o">--------------------------------------------------------</span>

<span class="n">Input</span> <span class="n">filename</span> <span class="k">for</span> <span class="n">network</span> <span class="n">definition</span> <span class="n">sequence</span> <span class="p">(</span><span class="o">&lt;</span><span class="k">return</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">set_def</span><span class="o">.</span><span class="n">out</span>  <span class="p">)</span>

<span class="n">To</span> <span class="nb">input</span> <span class="n">a</span> <span class="n">regularly</span> <span class="n">repeating</span> <span class="n">time</span> <span class="n">sequence</span> <span class="n">enter</span> <span class="mi">1</span>
<span class="n">To</span> <span class="n">enter</span> <span class="n">an</span> <span class="n">irregular</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">times</span> <span class="n">enter</span> <span class="mi">2</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>We now will input the number of observations in the file. The purpose of
this exercise is to refine the time step used by Lorenz in 1963 by a
factor of 10. Since we want to keep the ratio of six model steps per
observation and run for 50 days, we will need 2000 model observations
(360 seconds × 6 × 2000 = 50 days).</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: as we specified in <code class="docutils literal notranslate"><span class="pre">set_def.out</span></code>, there are 3</p>
</dd>
</dl>
<p>observations per time step, so a total of 6000 observations will be
generated.</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: the Lorenz 63 model dimensional time-step is related to</p>
</dd>
</dl>
<p>the observational time <em>only</em> through this mechanism. In other words,
<code class="docutils literal notranslate"><span class="pre">deltat</span></code> in the namelist could relate to virtually any dimensional
time step <code class="docutils literal notranslate"><span class="pre">time_step_seconds</span></code> if the observation times were not
considered. However, DART will automatically advance the model state to
the observation times in order to conduct the data assimilation at the
appropriate time, then repeat this process until no additional
observations are available, thus indirectly linking <code class="docutils literal notranslate"><span class="pre">deltat</span></code> to
<code class="docutils literal notranslate"><span class="pre">time_step_seconds</span></code>.</p>
<p>Enter <strong>2000</strong> for the number of observation times. The initial time
will be <strong>0 0</strong>, and the input period will be <strong>0</strong> days and <strong>2160</strong>
seconds (36 minutes).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span> <span class="n">number</span> <span class="n">of</span> <span class="n">observation</span> <span class="n">times</span> <span class="ow">in</span> <span class="n">sequence</span>
<span class="mi">2000</span>
<span class="n">Input</span> <span class="n">initial</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">sequence</span>
<span class="nb">input</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">days</span> <span class="ow">and</span> <span class="n">seconds</span> <span class="p">(</span><span class="k">as</span> <span class="n">integers</span><span class="p">)</span>
<span class="mi">0</span> <span class="mi">0</span>
<span class="n">Input</span> <span class="n">period</span> <span class="n">of</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">sequence</span> <span class="ow">in</span> <span class="n">days</span> <span class="ow">and</span> <span class="n">seconds</span>
<span class="mi">0</span> <span class="mi">2160</span>
</pre></div>
</div>
<p>The numbers 1 to 2000 will then be output by
<code class="docutils literal notranslate"><span class="pre">create_fixed_network_seq</span></code>. Press return to accept the default output
name of <code class="docutils literal notranslate"><span class="pre">obs_seq.in</span></code>. The file suffix is <code class="docutils literal notranslate"><span class="pre">.in</span></code> as this will be the
input to the next program, <em>perfect_model_obs</em>.</p>
<p>1 2</p>
<p>1998 1999 2000 What is output file name for sequence ( for obs_seq.in)</p>
<p>write_obs_seq opening formatted observation sequence file “obs_seq.in”
write_obs_seq closed observation sequence file “obs_seq.in”
create_fixed_network_seq Finished successfully.</p>
</div>
<div class="section" id="running-perfect-model-obs">
<h4>Running perfect_model_obs<a class="headerlink" href="#running-perfect-model-obs" title="Permalink to this headline">¶</a></h4>
<p>We are now ready to run <em>perfect_model_obs</em>, which will read in
<code class="docutils literal notranslate"><span class="pre">obs_seq.in</span></code> and generate the observations as well as create the
“perfect” model trajectory. “Perfect” here is a synonym for the known
“true” state which is used to generate the observations. Once noise is
added (to represent observational uncertainty), the output is written to
<code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code>.</p>
<blockquote>
<div><div class="line-block">
<div class="line"># Make sure you are in the DARTHOME/models/lorenz_63/work directory</div>
<div class="line">./perfect_model_obs</div>
</div>
</div></blockquote>
<p>The output should look like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_nml_output</span> <span class="n">Echo</span> <span class="n">NML</span> <span class="n">values</span> <span class="n">to</span> <span class="n">log</span> <span class="n">file</span> <span class="n">only</span>
 <span class="n">initialize_mpi_utilities</span><span class="p">:</span> <span class="n">Running</span> <span class="n">single</span> <span class="n">process</span>

<span class="o">--------------------------------------------------------</span>
<span class="o">--------------</span> <span class="n">ASSIMILATE_THESE_OBS_TYPES</span> <span class="o">--------------</span>
   <span class="n">RAW_STATE_VARIABLE</span>
<span class="o">--------------------------------------------------------</span>
<span class="o">--------------</span> <span class="n">EVALUATE_THESE_OBS_TYPES</span>   <span class="o">--------------</span>
   <span class="n">none</span>
<span class="o">--------------------------------------------------------</span>
<span class="o">----------</span> <span class="n">USE_PRECOMPUTED_FO_OBS_TYPES</span>   <span class="o">--------------</span>
   <span class="n">none</span>
<span class="o">--------------------------------------------------------</span>

 <span class="n">quality_control_mod</span><span class="p">:</span> <span class="n">Will</span> <span class="n">reject</span> <span class="n">obs</span> <span class="k">with</span> <span class="n">Data</span> <span class="n">QC</span> <span class="n">larger</span> <span class="n">than</span>    <span class="mi">3</span>
 <span class="n">quality_control_mod</span><span class="p">:</span> <span class="n">No</span> <span class="n">observation</span> <span class="n">outlier</span> <span class="n">threshold</span> <span class="n">rejection</span> <span class="n">will</span> <span class="n">be</span> <span class="n">done</span>
 <span class="n">perfect_main</span>  <span class="n">Model</span> <span class="n">size</span> <span class="o">=</span>                     <span class="mi">3</span>
 <span class="n">perfect_read_restart</span><span class="p">:</span> <span class="n">reading</span> <span class="nb">input</span> <span class="n">state</span> <span class="kn">from</span> <span class="nn">file</span>
 <span class="n">perfect_main</span>  <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">sequence</span> <span class="ow">is</span>         <span class="mi">6000</span>
 <span class="n">perfect_main</span>  <span class="n">number</span> <span class="n">of</span> <span class="n">qc</span> <span class="n">values</span> <span class="ow">is</span>            <span class="mi">1</span>

 <span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">Main</span> <span class="n">evaluation</span> <span class="n">loop</span><span class="p">,</span> <span class="n">starting</span> <span class="n">iteration</span>    <span class="mi">0</span>
 <span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">starts</span>    <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>       <span class="mi">0</span> <span class="n">sec</span><span class="o">=</span>     <span class="mi">0</span>
 <span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">ends</span>      <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>       <span class="mi">0</span> <span class="n">sec</span><span class="o">=</span>   <span class="mi">180</span>
 <span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">Model</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">need</span> <span class="n">to</span> <span class="n">run</span><span class="p">;</span> <span class="n">data</span> <span class="n">already</span> <span class="n">at</span> <span class="n">required</span> <span class="n">time</span>
 <span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">Ready</span> <span class="n">to</span> <span class="n">evaluate</span> <span class="n">up</span> <span class="n">to</span>       <span class="mi">3</span> <span class="n">observations</span>

 <span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">Main</span> <span class="n">evaluation</span> <span class="n">loop</span><span class="p">,</span> <span class="n">starting</span> <span class="n">iteration</span>    <span class="mi">1</span>
 <span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">starts</span>    <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>       <span class="mi">0</span> <span class="n">sec</span><span class="o">=</span>  <span class="mi">1981</span>
 <span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">ends</span>      <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>       <span class="mi">0</span> <span class="n">sec</span><span class="o">=</span>  <span class="mi">2340</span>
 <span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">Ready</span> <span class="n">to</span> <span class="n">run</span> <span class="n">model</span> <span class="n">to</span> <span class="n">advance</span> <span class="n">data</span> <span class="n">ahead</span> <span class="ow">in</span> <span class="n">time</span>
 <span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">Ready</span> <span class="n">to</span> <span class="n">evaluate</span> <span class="n">up</span> <span class="n">to</span>       <span class="mi">3</span> <span class="n">observations</span>


<span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">Main</span> <span class="n">evaluation</span> <span class="n">loop</span><span class="p">,</span> <span class="n">starting</span> <span class="n">iteration</span> <span class="mi">1999</span>
<span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">starts</span>    <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>      <span class="mi">49</span> <span class="n">sec</span><span class="o">=</span> <span class="mi">84061</span>
<span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">ends</span>      <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>      <span class="mi">49</span> <span class="n">sec</span><span class="o">=</span> <span class="mi">84420</span>
<span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">Ready</span> <span class="n">to</span> <span class="n">run</span> <span class="n">model</span> <span class="n">to</span> <span class="n">advance</span> <span class="n">data</span> <span class="n">ahead</span> <span class="ow">in</span> <span class="n">time</span>
<span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">Ready</span> <span class="n">to</span> <span class="n">evaluate</span> <span class="n">up</span> <span class="n">to</span>       <span class="mi">3</span> <span class="n">observations</span>

<span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">Main</span> <span class="n">evaluation</span> <span class="n">loop</span><span class="p">,</span> <span class="n">starting</span> <span class="n">iteration</span> <span class="mi">2000</span>
<span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">No</span> <span class="n">more</span> <span class="n">obs</span> <span class="n">to</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">exiting</span> <span class="n">main</span> <span class="n">loop</span>
<span class="n">perfect_model_obs</span><span class="p">:</span> <span class="n">End</span> <span class="n">of</span> <span class="n">main</span> <span class="n">evaluation</span> <span class="n">loop</span><span class="p">,</span> <span class="n">starting</span> <span class="n">cleanup</span>
<span class="n">write_obs_seq</span>  <span class="n">opening</span> <span class="n">formatted</span> <span class="n">observation</span> <span class="n">sequence</span> <span class="n">file</span> <span class="s2">&quot;obs_seq.out&quot;</span>
<span class="n">write_obs_seq</span>  <span class="n">closed</span> <span class="n">observation</span> <span class="n">sequence</span> <span class="n">file</span> <span class="s2">&quot;obs_seq.out&quot;</span>
</pre></div>
</div>
<p>You can now see the files <code class="docutils literal notranslate"><span class="pre">true_state.nc</span></code>, a netCDF file which has the
perfect model state at all 2000 observation times; <code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code>, an
ASCII file which contains the 6000 observations (2000 times with 3
observations each) of the true model state with noise added in; and
<code class="docutils literal notranslate"><span class="pre">perfect_output.nc</span></code>, a netCDF file with the final true state that
could be used to “restart” the experiment from the final time (49.75
days in this case).</p>
<p>We can now see the relationship between <code class="docutils literal notranslate"><span class="pre">obs_seq.in</span></code> and
<code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code>: <code class="docutils literal notranslate"><span class="pre">obs_seq.in</span></code> contains a “template” of the desired
observation locations and types, while <code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code> is a list of the
actual observation values, in this case generated by the
<em>perfect_model_obs</em> program.</p>
<dl class="field-list simple">
<dt class="field-odd">exclamation</dt>
<dd class="field-odd"><p><em>IMPORTANT</em>: <code class="docutils literal notranslate"><span class="pre">create_obs_seq</span></code> is used for this low-order</p>
</dd>
</dl>
<p>model because there are no real observations for Lorenz 63. For systems
that have real observations, DART provides a variety of <em>observation
converters</em> available to convert from native observation formats to the
DART format. See <a class="reference external" href="#obsConverters">Observation converters provided by
DART</a> for a list.</p>
</div>
<div class="section" id="running-the-filter">
<h4>Running the filter<a class="headerlink" href="#running-the-filter" title="Permalink to this headline">¶</a></h4>
<p>Now that <code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code> and <code class="docutils literal notranslate"><span class="pre">true_state.nc</span></code> have been prepared, DART
can perform the actual data assimilation. This will generate an ensemble
of model states, use the ensemble to estimate the prior distribution,
compare to the “expected” observation of each member, and update the
model state according to Bayes’ rule.</p>
<blockquote>
<div><p># Make sure you are in the DARTHOME/models/lorenz_63/work directory
./filter</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_nml_output</span> <span class="n">Echo</span> <span class="n">NML</span> <span class="n">values</span> <span class="n">to</span> <span class="n">log</span> <span class="n">file</span> <span class="n">only</span>
<span class="n">initialize_mpi_utilities</span><span class="p">:</span> <span class="n">Running</span> <span class="n">single</span> <span class="n">process</span>

<span class="o">--------------------------------------------------------</span>
<span class="o">--------------</span> <span class="n">ASSIMILATE_THESE_OBS_TYPES</span> <span class="o">--------------</span>
  <span class="n">RAW_STATE_VARIABLE</span>
<span class="o">--------------------------------------------------------</span>
<span class="o">--------------</span> <span class="n">EVALUATE_THESE_OBS_TYPES</span>   <span class="o">--------------</span>
  <span class="n">none</span>
<span class="o">--------------------------------------------------------</span>
<span class="o">----------</span> <span class="n">USE_PRECOMPUTED_FO_OBS_TYPES</span>   <span class="o">--------------</span>
  <span class="n">none</span>
<span class="o">--------------------------------------------------------</span>

<span class="n">quality_control_mod</span><span class="p">:</span> <span class="n">Will</span> <span class="n">reject</span> <span class="n">obs</span> <span class="k">with</span> <span class="n">Data</span> <span class="n">QC</span> <span class="n">larger</span> <span class="n">than</span>    <span class="mi">3</span>
<span class="n">quality_control_mod</span><span class="p">:</span> <span class="n">No</span> <span class="n">observation</span> <span class="n">outlier</span> <span class="n">threshold</span> <span class="n">rejection</span> <span class="n">will</span> <span class="n">be</span> <span class="n">done</span>
<span class="n">assim_tools_init</span><span class="p">:</span> <span class="n">Selected</span> <span class="nb">filter</span> <span class="nb">type</span> <span class="ow">is</span> <span class="n">Ensemble</span> <span class="n">Adjustment</span> <span class="n">Kalman</span> <span class="n">Filter</span> <span class="p">(</span><span class="n">EAKF</span><span class="p">)</span>
<span class="n">assim_tools_init</span><span class="p">:</span> <span class="n">The</span> <span class="n">cutoff</span> <span class="n">namelist</span> <span class="n">value</span> <span class="ow">is</span>     <span class="mf">1000000.000000</span>
<span class="n">assim_tools_init</span><span class="p">:</span> <span class="o">...</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">localization</span> <span class="n">half</span><span class="o">-</span><span class="n">width</span> <span class="n">parameter</span><span class="p">,</span>
<span class="n">assim_tools_init</span><span class="p">:</span> <span class="o">...</span> <span class="n">so</span> <span class="n">the</span> <span class="n">effective</span> <span class="n">localization</span> <span class="n">radius</span> <span class="ow">is</span>     <span class="mf">2000000.000000</span>
<span class="n">filter_main</span><span class="p">:</span> <span class="n">running</span> <span class="k">with</span> <span class="n">an</span> <span class="n">ensemble</span> <span class="n">size</span> <span class="n">of</span>    <span class="mi">20</span>
<span class="n">parse_stages_to_write</span><span class="p">:</span>  <span class="nb">filter</span> <span class="n">will</span> <span class="n">write</span> <span class="n">stage</span> <span class="p">:</span> <span class="n">preassim</span>
<span class="n">parse_stages_to_write</span><span class="p">:</span>  <span class="nb">filter</span> <span class="n">will</span> <span class="n">write</span> <span class="n">stage</span> <span class="p">:</span> <span class="n">analysis</span>
<span class="n">parse_stages_to_write</span><span class="p">:</span>  <span class="nb">filter</span> <span class="n">will</span> <span class="n">write</span> <span class="n">stage</span> <span class="p">:</span> <span class="n">output</span>
<span class="n">set_member_file_metadata</span> <span class="n">no</span> <span class="n">file</span> <span class="nb">list</span> <span class="n">given</span> <span class="k">for</span> <span class="n">stage</span> <span class="s2">&quot;preassim&quot;</span> <span class="n">so</span> <span class="n">using</span> <span class="n">default</span> <span class="n">names</span>
<span class="n">set_member_file_metadata</span> <span class="n">no</span> <span class="n">file</span> <span class="nb">list</span> <span class="n">given</span> <span class="k">for</span> <span class="n">stage</span> <span class="s2">&quot;analysis&quot;</span> <span class="n">so</span> <span class="n">using</span> <span class="n">default</span> <span class="n">names</span>
<span class="n">Prior</span> <span class="n">inflation</span><span class="p">:</span> <span class="kc">None</span>
<span class="n">Posterior</span> <span class="n">inflation</span><span class="p">:</span> <span class="kc">None</span>
<span class="n">filter_main</span><span class="p">:</span> <span class="n">Reading</span> <span class="ow">in</span> <span class="n">initial</span> <span class="n">condition</span><span class="o">/</span><span class="n">restart</span> <span class="n">data</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">ensemble</span> <span class="n">members</span> <span class="kn">from</span> <span class="nn">file</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="nb">filter</span><span class="p">:</span> <span class="n">Main</span> <span class="n">assimilation</span> <span class="n">loop</span><span class="p">,</span> <span class="n">starting</span> <span class="n">iteration</span>    <span class="mi">0</span>
<span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">starts</span>    <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>       <span class="mi">0</span> <span class="n">sec</span><span class="o">=</span>     <span class="mi">0</span>
<span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">ends</span>      <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>       <span class="mi">0</span> <span class="n">sec</span><span class="o">=</span>   <span class="mi">180</span>
<span class="nb">filter</span><span class="p">:</span> <span class="n">Model</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">need</span> <span class="n">to</span> <span class="n">run</span><span class="p">;</span> <span class="n">data</span> <span class="n">already</span> <span class="n">at</span> <span class="n">required</span> <span class="n">time</span>
<span class="nb">filter</span><span class="p">:</span> <span class="n">Ready</span> <span class="n">to</span> <span class="n">assimilate</span> <span class="n">up</span> <span class="n">to</span>       <span class="mi">3</span> <span class="n">observations</span>
<span class="n">comp_cov_factor</span><span class="p">:</span> <span class="n">Standard</span> <span class="n">Gaspari</span> <span class="n">Cohn</span> <span class="n">localization</span> <span class="n">selected</span>
<span class="n">filter_assim</span><span class="p">:</span> <span class="n">Processed</span>       <span class="mi">3</span> <span class="n">total</span> <span class="n">observations</span>

<span class="nb">filter</span><span class="p">:</span> <span class="n">Main</span> <span class="n">assimilation</span> <span class="n">loop</span><span class="p">,</span> <span class="n">starting</span> <span class="n">iteration</span>    <span class="mi">1</span>
<span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">starts</span>    <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>       <span class="mi">0</span> <span class="n">sec</span><span class="o">=</span> <span class="mi">21421</span>
<span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">ends</span>      <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>       <span class="mi">0</span> <span class="n">sec</span><span class="o">=</span> <span class="mi">21780</span>
<span class="nb">filter</span><span class="p">:</span> <span class="n">Ready</span> <span class="n">to</span> <span class="n">run</span> <span class="n">model</span> <span class="n">to</span> <span class="n">advance</span> <span class="n">data</span> <span class="n">ahead</span> <span class="ow">in</span> <span class="n">time</span>
<span class="nb">filter</span><span class="p">:</span> <span class="n">Ready</span> <span class="n">to</span> <span class="n">assimilate</span> <span class="n">up</span> <span class="n">to</span>       <span class="mi">3</span> <span class="n">observations</span>
<span class="n">filter_assim</span><span class="p">:</span> <span class="n">Processed</span>       <span class="mi">3</span> <span class="n">total</span> <span class="n">observations</span>

<span class="nb">filter</span><span class="p">:</span> <span class="n">Main</span> <span class="n">assimilation</span> <span class="n">loop</span><span class="p">,</span> <span class="n">starting</span> <span class="n">iteration</span>  <span class="mi">199</span>
<span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">starts</span>    <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>      <span class="mi">49</span> <span class="n">sec</span><span class="o">=</span> <span class="mi">64621</span>
<span class="n">move_ahead</span> <span class="n">Next</span> <span class="n">assimilation</span> <span class="n">window</span> <span class="n">ends</span>      <span class="n">at</span><span class="p">:</span>  <span class="n">day</span><span class="o">=</span>      <span class="mi">49</span> <span class="n">sec</span><span class="o">=</span> <span class="mi">64980</span>
<span class="nb">filter</span><span class="p">:</span> <span class="n">Ready</span> <span class="n">to</span> <span class="n">run</span> <span class="n">model</span> <span class="n">to</span> <span class="n">advance</span> <span class="n">data</span> <span class="n">ahead</span> <span class="ow">in</span> <span class="n">time</span>
<span class="nb">filter</span><span class="p">:</span> <span class="n">Ready</span> <span class="n">to</span> <span class="n">assimilate</span> <span class="n">up</span> <span class="n">to</span>       <span class="mi">3</span> <span class="n">observations</span>
<span class="n">filter_assim</span><span class="p">:</span> <span class="n">Processed</span>       <span class="mi">3</span> <span class="n">total</span> <span class="n">observations</span>

<span class="nb">filter</span><span class="p">:</span> <span class="n">Main</span> <span class="n">assimilation</span> <span class="n">loop</span><span class="p">,</span> <span class="n">starting</span> <span class="n">iteration</span>  <span class="mi">200</span>
<span class="nb">filter</span><span class="p">:</span> <span class="n">No</span> <span class="n">more</span> <span class="n">obs</span> <span class="n">to</span> <span class="n">assimilate</span><span class="p">,</span> <span class="n">exiting</span> <span class="n">main</span> <span class="n">loop</span>
<span class="nb">filter</span><span class="p">:</span> <span class="n">End</span> <span class="n">of</span> <span class="n">main</span> <span class="nb">filter</span> <span class="n">assimilation</span> <span class="n">loop</span><span class="p">,</span> <span class="n">starting</span> <span class="n">cleanup</span>
<span class="n">write_obs_seq</span>  <span class="n">opening</span> <span class="n">formatted</span> <span class="n">observation</span> <span class="n">sequence</span> <span class="n">file</span> <span class="s2">&quot;obs_seq.final&quot;</span>
<span class="n">write_obs_seq</span>  <span class="n">closed</span> <span class="n">observation</span> <span class="n">sequence</span> <span class="n">file</span> <span class="s2">&quot;obs_seq.final&quot;</span>
</pre></div>
</div>
<p>Based on the default Lorenz 63 <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> namelist for <em>filter</em>
included in the DART repository, the assimilation will have three
stages:</p>
<ol class="arabic simple">
<li><p>The <em>preassim</em> stage, where the ensemble is updated by advancing the
model. The file<code class="docutils literal notranslate"><span class="pre">preassim.nc</span></code>, which contains the pre-assimilation
model trajectories for all the ensemble members, will be written.</p></li>
<li><p>The <em>analysis</em> stage, where the data assimilation is conducted. The
post-assimilation model trajectories for all the ensemble members
will be written to <code class="docutils literal notranslate"><span class="pre">analysis.nc</span></code></p></li>
<li><p>The <em>output</em> stage, which writes the file <code class="docutils literal notranslate"><span class="pre">obs_seq.final</span></code>
containing the actual observations as assimilated plus the ensemble
forward-operator expected values and any quality-control values. This
stage also writes the <code class="docutils literal notranslate"><span class="pre">filter_output.nc</span></code> file containing the
ensemble state from the final cycle, which could be used to restart
the experiment.</p></li>
</ol>
<p>DART has now successfully assimilated our updated observations with a 6
minute model time step and assimilation every 36 minutes. <em>:tada:</em></p>
</div>
<div class="section" id="verifying-the-nicer-looking-results">
<h4>Verifying the nicer-looking results<a class="headerlink" href="#verifying-the-nicer-looking-results" title="Permalink to this headline">¶</a></h4>
<p>You can now run the verification scripts (as in the section <a class="reference external" href="#verify">Verify the
results are correct</a>) in Matlab with the following commands:</p>
<blockquote>
<div><div class="line-block">
<div class="line">&gt;&gt; addpath ../../../diagnostics/matlab</div>
<div class="line">&gt;&gt; plot_ens_time_series</div>
</div>
</div></blockquote>
<p>Some additional commands to view the attractor from the ZY plane were
used:</p>
<blockquote>
<div><div class="line-block">
<div class="line">&gt;&gt; set(findall(gca, ‘Type’, ‘Line’),‘LineWidth’,2);</div>
<div class="line">&gt;&gt; set(gca,‘FontSize’,18)</div>
<div class="line">&gt;&gt; xlabel(‘x’)</div>
<div class="line">&gt;&gt; ylabel(‘y’)</div>
<div class="line">&gt;&gt; zlabel(‘z’)</div>
<div class="line">&gt;&gt; view([90 0])</div>
</div>
</div></blockquote>
<p>We can now see the following smooth Lorenz 63 true state and ensemble
mean comparison with a 6 minute model time step and assimilation every
36 minutes:</p>
<p>As you can see, the ensemble mean in red matches the true state almost
exactly, although it took a number of assimilation cycles before the
blue ensemble mean was able to reach the red true state “attractor.”</p>
<p>You should now be able to play with the Lorenz 63 and/or other models in
DART. For more detailed information on the ins-and-outs of ensemble DA,
see <a class="reference external" href="#DartForEducation">How would I use DART for teaching students and/or
myself?</a>. For more concrete information regarding
DART’s algorithms and capabilities, see the next section: <a class="reference external" href="#WhatIsDART">What is
DART?</a>. To add your own model to DART, see <a class="reference external" href="#RunWithMyModel">How do I run
DART with my model?</a>. Finally, if you wish to add
your own observations to DART, see <a class="reference external" href="#RunWithMyObs">How do I add my observations to
DART?</a>.</p>
<hr class="docutils" />
<p>` &lt;#WhatIsDART&gt;`__</p>
</div>
</div>
</div>
<div class="section" id="what-is-dart">
<h2>What is DART?<a class="headerlink" href="#what-is-dart" title="Permalink to this headline">¶</a></h2>
<p>[<a class="reference external" href="#top">top</a>]</p>
<p>The Data Assimilation Research Testbed (DART) is an open-source
community facility that provides software tools for data assimilation
research, development, and education. Using DART’s carefully engineered
ensemble data assimilation algorithms and diagnostic tools, atmospheric
scientists, oceanographers, hydrologists, chemists, and other
geophysicists can construct state-of-the-art data assimilation systems
with unprecedented ease.</p>
<p>In this section we will introduce DART in further detail. This includes:</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="#whyDart">Why should I use DART for my project?</a></p></li>
<li><p><a class="reference external" href="#dartHistory">A brief history of DART</a></p></li>
<li><p><a class="reference external" href="#dartWorkflow">A high-level workflow of DA in DART</a></p></li>
<li><p><a class="reference external" href="#dartDesign">DART’s design philosophy</a></p></li>
<li><p><a class="reference external" href="#dartCapabilities">Important capabilities of DART</a></p></li>
<li><p><a class="reference external" href="#citeDart">How to cite DART</a></p></li>
</ol>
<p>` &lt;#whyDart&gt;`__</p>
<div class="section" id="why-should-i-use-dart-for-my-project">
<h3>Why should I use DART for my project?<a class="headerlink" href="#why-should-i-use-dart-for-my-project" title="Permalink to this headline">¶</a></h3>
<p>A common pitfall for graduate students and professionals alike is to
look at the simplicity of data assimilation, in particular ensemble data
assimilation, and decide they can easily write their own DA system.
Indeed, this is true. After learning of the core algorithms, a talented
programmer using their favorite language could write a functional DA
system in a manner of weeks if not days. However, he or she will soon
find that while the core of DA systems are easy to write, the more
“real” the system needs to be, the more complex it will become. Writing
a parallel DA system that can efficiently utilize multiple cores with
MPI is not straight-forward, and adding covariance localization,
observation operators, multiple models, and auxiliary tools such as
quality control and pre-processing will quickly dwarf the amount of core
DA code, not to mention the headaches involved in supporting multiple
computing environments, compilers, etc.</p>
<p>DART employs a modular programming approach to apply an algorithm to
move the underlying models toward a state that is more consistent with
information from a set of observations. Models may be swapped in and
out, as can different DA algorithms. The method requires running
multiple instances of a model to generate an ensemble of states. A
forward operator appropriate for the type of observation being
assimilated is applied to each of the states to generate the model’s
estimate of the observation.</p>
<p>DART remains the top choice for scientists, educators, and
mathematicians seeking mature and robust ensemble DA solutions without
reinventing the wheel. Here are some of the many benefits of using DART:</p>
<ol class="arabic simple">
<li><p>DART is <strong>freely available, open source, and released under
the</strong><a class="reference external" href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0
License</a><strong>.</strong> In
short this means that you are granted a copyright license stating you
are free to use, modify, and redistribute any derivative works
derived from the DART system provided that you maintain the license
and copyright information. Of course, we also ask that you credit
DART in your publications, and kindly ask that you contribute your
modifications so that other users may benefit. See <a class="reference external" href="#citeDart">How should I cite
DART?</a> and <a class="reference external" href="#ContributeToDart">How can I contribute to
DART?</a> for more information.</p></li>
<li><p>DART is <strong>fully parallel and carefully engineered</strong> to run on systems
ranging from single-core research computers to the top performing
multicore supercomputers in the world. Writing scalable parallel code
is arguably the most difficult and time-consuming task in scientific
computing today, but DART has already carefully implemented and
tested this project, and the code is available for you to use
out-of-the-box. For more information on how DART was written (and
continues to be developed), see <a class="reference external" href="#dartDesign">DART’s design
philosophy</a>.</p></li>
<li><p>DART contains <strong>numerous tools that accelerate getting started</strong> on
both research and “real-world” problems. Multiple rigorously tested
inflation, localization, perturbation, and other auxiliary data
assimilation algorithms are available for immediate use and testing.
See <a class="reference external" href="#dartCapabilities">Important capabilities of DART</a> for more
information.</p></li>
<li><p>DART <strong>makes adding a new model straightforward</strong>. A new model only
needs to implement a list of (at most) 18 core functions or use the
default behavior if applicable to take advantage of DART’s mature and
robust DA algorithms. A basic data assimilation system for a large
model can be built in person-weeks, and comprehensive systems have
been built in a few months. See <a class="reference external" href="#RunWithMyModel">How do I run DART with my
model?</a> for more information.</p></li>
<li><p>DART <strong>makes it easy to add new observations</strong> in order to test their
potential beneficial impact. Incorporating new observation types only
requires creating a forward operator that computes the expected value
of an observation given a model’s state. See <a class="reference external" href="#RunWithMyObs">How do I add my
observations to DART?</a> for more information.</p></li>
<li><p>DART <strong>can be used to test new DA algorithms</strong>. Many such algorithms
have been successfully implemented, tested, and published using DART.
This is not covered in this getting started guide as this is an
“advanced user” functionality, so for this purpose it is best to
first get in touch with the DART team at dart &#64; ucar.edu to make the
process as smooth as possible.</p></li>
<li><p>Finally, and perhaps most importantly, DART <strong>has world-class
support</strong> available from the DART team at NCAR. A talented team of
dedicated software engineers and data assimilation scientists work
together to continually improve DART and support user needs. See the
<a class="reference external" href="About_Us.md">About us</a> for more information about the DART team.</p></li>
</ol>
<p>` &lt;#dartHistory&gt;`__</p>
</div>
<div class="section" id="a-brief-history-of-dart">
<h3>A brief history of DART<a class="headerlink" href="#a-brief-history-of-dart" title="Permalink to this headline">¶</a></h3>
<p>The DART project was initiated in August 2001, and in 2003, the Data
Assimilation Research Section (DAReS) was officially formed at NCAR. In
2004, the first officially supported version of DART was released.
Consistent version control history is available back to 2005, making
DART an extremely long-lived and well-supported software project. Since
2004, there have been more than a dozen releases. The first release,
<em>Easter</em>, began the trend of naming the major releases after islands in
alphabetical order in the following sequence:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 37%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Release</p></th>
<th class="head"><p>Date</p></th>
<th class="head"><p>Brief description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Easter</p></td>
<td><p>8 Mar 2004</p></td>
<td><p>Initial release</p></td>
</tr>
<tr class="row-odd"><td><p>Fiji</p></td>
<td><p>29 Apr 2004</p></td>
<td><p>Enhanced portability;
support for CAM and WRF</p></td>
</tr>
<tr class="row-even"><td><p>Guam</p></td>
<td><p>12 Aug 2004</p></td>
<td><p>New observation modules</p></td>
</tr>
<tr class="row-odd"><td><p>Pre-Hawaii</p></td>
<td><p>20 Dec 2004</p></td>
<td><p>New filtering
algorithms</p></td>
</tr>
<tr class="row-even"><td><p>Hawaii</p></td>
<td><p>28 Feb 2005</p></td>
<td><p>New filtering
algorithms</p></td>
</tr>
<tr class="row-odd"><td><p>DA Workshop 2005</p></td>
<td><p>13 Jun 2005</p></td>
<td><p>Tutorial, observation
preprocessing</p></td>
</tr>
<tr class="row-even"><td><p>Pre-Iceland</p></td>
<td><p>20 Oct 2005</p></td>
<td><p>Huge expansion of real
observation capability</p></td>
</tr>
<tr class="row-odd"><td><p>Iceland</p></td>
<td><p>23 Nov 2005</p></td>
<td><p>Huge expansion of real
observation capability,
more</p></td>
</tr>
<tr class="row-even"><td><p>Post-Iceland</p></td>
<td><p>20 Jun 2006</p></td>
<td><p>Observation-space
adaptive inflation,
more</p></td>
</tr>
<tr class="row-odd"><td><p>Pre-J</p></td>
<td><p>02 Oct 2006</p></td>
<td><p>Updated scalable filter
algorithm</p></td>
</tr>
<tr class="row-even"><td><p>Jamaica</p></td>
<td><p>12 Apr 2007</p></td>
<td><p>Vertical localization,
extensive MPI testing,
more</p></td>
</tr>
<tr class="row-odd"><td><p>Kodiak</p></td>
<td><p>30 Jun 2011</p></td>
<td><p>New obs types, new
diagnostics, new
utilities, much more</p></td>
</tr>
<tr class="row-even"><td><p>Lanai</p></td>
<td><p>13 Dec 2013</p></td>
<td><p>Support for many new
models,
chemistry/aerosol
types, new diagnostics,
new utilities, much
more</p></td>
</tr>
<tr class="row-odd"><td><p>Manhattan</p></td>
<td><p>15 May 2017</p></td>
<td><p>Native netCDF support,
better
scaling/performance,
much more</p></td>
</tr>
</tbody>
</table>
<p>In September 2009, DART was featured on the cover of the Bulletin of the
American Meteorological Society:</p>
<p>The September 2009 issue of BAMS can be found
<a class="reference external" href="https://journals.ametsoc.org/toc/bams/90/9">here</a>, while the DART
article can be found directly
<a class="reference external" href="https://journals.ametsoc.org/doi/full/10.1175/2009BAMS2618.1">here</a>.</p>
<p>On the <a class="reference external" href="Publications.md">Publications</a> page there are over 40 example
publications that use DART, although there are many additional
publications using DART not listed. The seminal BAMS paper has over 400
citations according to <a class="reference external" href="http://scholar.google.com">Google Scholar</a>.
The core algorithms used in DART have also been cited many more times.
For example, the core EAKF algorithm (<a class="reference external" href="https://journals.ametsoc.org/doi/full/10.1175/1520-0493%282001%29129%3C2884%3AAEAKFF%3E2.0.CO%3B2">Anderson
2001</a>)
used in DART has over 1500 citations according to Google scholar.</p>
<p>` &lt;#dartWorkflow&gt;`__</p>
</div>
<div class="section" id="high-level-da-workflows-in-dart">
<h3>High-level DA workflows in DART<a class="headerlink" href="#high-level-da-workflows-in-dart" title="Permalink to this headline">¶</a></h3>
<p>In this section we present two high-level data assimilation workflows
that show the relevant DART programs with their inputs and outputs.
These two workflows represent two different types of DA experiments
typically run.</p>
<p>It is possible to run DART in <strong>Observation System Simulation Experiment
(OSSE)</strong> mode. In OSSE mode, a perfect “true” model trajectory is
created, and synthetic observations are generated from the “truth” with
added noise. This is useful to test the theoretical capability of DA
algorithms, observations, and/or models. In this document so far, we
have conducted only OSSEs.</p>
<p>It is also possible to run DART in a more realistic <strong>Observation System
Experiment (OSE)</strong> mode. In an OSE, there is no perfect model truth,
which is similar to real-world situations where the true values of the
model state will likely never be perfectly known. The observations
(which again themselves are noisy and imperfect) are the only way to get
a look at the “truth” that is estimated by the model state. In OSE mode,
the user must provide observations to DART, which are usually from
real-world observation systems (which come with all of their own
idiosyncrasies and imperfections). DART can help generate ensemble
perturbations, or the user can specify their own.</p>
<p>The filtering aspect is the same for both OSSE and OSE experiments, and
many of the same tools for data assimilation are available in OSSE and
OSE modes. The core difference, therefore, is the existence of the
perfect model “truth.”</p>
<p>For a simple model such as Lorenz 63 investigated above, DART can
typically advance the model time explicitly through a Fortran function
call, allowing the filtering to compute all necessary time steps in
sequence without exiting the DART program. However, for larger models
(or those that DART cannot communicate with through Fortran), a
shell-script may be necessary to run the model and advance the time
forward. For the largest models, the model state is typically advanced
in parallel over many computing nodes on a supercomputer. In this more
complex case, DART only considers one step at a time in order to combine
the observations and the prior ensemble to find the posterior analysis,
which will then be used to restart the model and continue the forecast.</p>
<p>For efficiency reasons, data from models with large states may be
written in separate files for every ensemble member at every stage of
the assimilation process. Data from models with small states may be
conveniently be written as variables inside a single netCDF file.</p>
<div class="section" id="simple-model-workflow-with-an-osse">
<h4>Simple model workflow with an OSSE<a class="headerlink" href="#simple-model-workflow-with-an-osse" title="Permalink to this headline">¶</a></h4>
<p>The first example DA workflow is for a model that can be advanced by
DART with all ensemble members stored in a single file running an OSSE:</p>
<p>As shown, the program <em>preprocess</em> takes the <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> namelist file
and generates Fortran code for the observations. This code, along with
the namelist, is used by all subsequent programs. <em>create_obs_seq</em> is
used to define a set of observations in <code class="docutils literal notranslate"><span class="pre">set_def.out</span></code>, which can be
replicated through the program <em>create_fixed_network_seq</em> to create a
<code class="docutils literal notranslate"><span class="pre">obs_seq.in</span></code> file. There are two inputs to <em>perfect_model_obs</em>: the
<code class="docutils literal notranslate"><span class="pre">obs_seq.in</span></code> file and <code class="docutils literal notranslate"><span class="pre">perfect_input.nc</span></code> (which here is generated by
<code class="docutils literal notranslate"><span class="pre">perfect_input.cdl</span></code> via <em>ncgen</em>). <code class="docutils literal notranslate"><span class="pre">obs_seq.in</span></code> provides
<em>perfect_model_obs</em> with the observation template (i.e. the location and
type of observations), while <code class="docutils literal notranslate"><span class="pre">perfect_input.nc</span></code> provides the initial
state that will be used to advance the model. On output, the “perfect”
model state at the final time, which can be used as a restart for
running this procedure again, will be written to <code class="docutils literal notranslate"><span class="pre">perfect_output.nc</span></code>
(i.e. <code class="docutils literal notranslate"><span class="pre">perfect_output.nc</span></code> could be renamed to <code class="docutils literal notranslate"><span class="pre">perfect_input.nc</span></code> to
extend the OSSE), while the entire state trajectory will be stored in
<code class="docutils literal notranslate"><span class="pre">true_state.nc</span></code>. The noisy synthetic observations and noise-free truth
(for verification only) will be stored in <code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code>. The
observation values of <code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code> will be input to <em>filter</em> along
with the <code class="docutils literal notranslate"><span class="pre">filter_input.nc</span></code> (generated by <code class="docutils literal notranslate"><span class="pre">filter_input.cdl</span></code> via
<em>ncgen</em>), which contains the initial state for all the ensemble members.
The output of <em>filter</em> is <code class="docutils literal notranslate"><span class="pre">preassim.nc</span></code>, which contains the prior
state for all the ensemble members just before applying DA (so including
prior inflation if it is being used); <code class="docutils literal notranslate"><span class="pre">analysis.nc</span></code>, which contains
the posterior state for all the ensemble members after assimilation (and
including inflation if it is being used); <code class="docutils literal notranslate"><span class="pre">filter_output.nc</span></code>, which is
the final posterior that could be used to restart the OSSE process; and
<code class="docutils literal notranslate"><span class="pre">obs_seq.final</span></code>, which adds the forward-calculated expected values
<em>h</em>(<strong>x</strong>) for each observation. The <code class="docutils literal notranslate"><span class="pre">obs_seq.final</span></code> file can be
analyzed and binned by the <em>obs_diag</em> program, producing the file
<code class="docutils literal notranslate"><span class="pre">obs_diag_output.nc</span></code> which can be used for diagnostics.</p>
</div>
<div class="section" id="complex-model-workflow-with-an-ose">
<h4>Complex model workflow with an OSE<a class="headerlink" href="#complex-model-workflow-with-an-ose" title="Permalink to this headline">¶</a></h4>
<p>The second workflow is for a complex model with all ensemble members
stored in separate files running an OSE. In this case, DART will only
operate on one model output at a time. External programs will advance
the model states, generate the observations, and call DART again. The
following diagram in shows the high-level DART flow in this case:</p>
<p>Within a single time step, DART will use the <em>filter</em> program to run the
“Assimilate” portion of the above diagram and/or the “diagnostics” as
follows:</p>
<p>The single time-step workflow for an OSE experiment within a single step
is slightly simpler than the OSSE equivalent as DART handles less of the
process. Like the OSSE case, the namelist and preprocessed observation
source files are input to all other DART programs. In the OSE case,
however, the user must provide an <strong>obs converter</strong> that will output a
<code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code> file. There are many DART utilities to make this process
easier, but for the OSE case the <code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code> file is ultimately the
user’s responsibility (to avoid duplicating effort, see the list of
existing observation types in <a class="reference external" href="#dartCapabilities">Important capabilities of
DART</a>). Here, the option to run with one file for
each ensemble member is demonstrated. There are <em>k</em> ensemble members
used as input to <em>filter</em>, which also outputs <em>k</em> members for the prior
and posterior. The <code class="docutils literal notranslate"><span class="pre">obs_seq.final</span></code> and <code class="docutils literal notranslate"><span class="pre">obs_diag_output.nc</span></code> are used
in the same way as in the OSSE case. The names of the input files and
output files can be controlled by the user through the
<code class="docutils literal notranslate"><span class="pre">filter_input_list.txt</span></code> and <code class="docutils literal notranslate"><span class="pre">filter_output_list.txt</span></code> files, which
can contain the user-specified list of the ensemble input or output
files, respectively.</p>
<p>Another view of the stages of filter is shown in the following diagram:</p>
<p>As shown here, an ensemble forecast is stored in <code class="docutils literal notranslate"><span class="pre">forecast.nc</span></code> , to
which prior inflation can be applied and stored in <code class="docutils literal notranslate"><span class="pre">preassim.nc</span></code>. Once
assimilation is applied, the output can be stored in <code class="docutils literal notranslate"><span class="pre">postassim.nc</span></code>,
and finally if posterior inflation is applied, the final analysis can be
written in <code class="docutils literal notranslate"><span class="pre">analysis.nc</span></code> . The model forecast will start from the
analysis to advance the model in order to start the cycle over again.</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: the “forecast” will be the same as the “preassim” if</p>
</dd>
</dl>
<p>prior inflation is not used, and the “postassim” will be the same as the
“analysis” if posterior inflation is not used. The <em>stages_to_write</em>
variable in the “&amp;filter_nml” section of the <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> namelist
controls which stages are output to file. For a multi-file case, the
potential <em>stages_to_write</em> are “input, forecast, preassim, postassim,
analysis, output” while for a single file the same stages are available
with the exception of “input.”</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: in the above cycling diagram, there will actually be one</p>
</dd>
</dl>
<p>file per member, which is not shown here in order to simplify the
process.</p>
<dl class="field-list simple">
<dt class="field-odd">exclamation</dt>
<dd class="field-odd"><p><em>IMPORTANT</em>: the decision to store ensemble members as</p>
</dd>
</dl>
<p>separate files and whether to run an OSSE or OSE are independent. An
OSSE can be run with multiple files and an OSE can be run with all
ensemble members stored in a single file.</p>
<p>` &lt;#dartDesign&gt;`__</p>
</div>
</div>
<div class="section" id="darts-design-philosophy">
<h3>DART’s design philosophy<a class="headerlink" href="#darts-design-philosophy" title="Permalink to this headline">¶</a></h3>
<p>In this section we cover DART’s design philosophy. Understanding this
philosophy will make it easier to get started with DART, as you will
quickly be able to predict how and where to find a particular feature of
DART.</p>
<p>The main design goals of DART are to:</p>
<ol class="arabic simple">
<li><p>Create a system that is <strong>coherent</strong> and <strong>easy to understand</strong>. DART
is carefully engineered to have self-contained programs that each do
one job and do it well. Likewise, DART <em>just does DA, and does it
well.</em></p></li>
<li><p>Release source code that is <strong>as compatible as possible</strong> with the
widest possible number of systems. The code is written in Fortran 90,
which is one of the lowest possible common denominators available on
virtually all systems. See the section <a class="reference external" href="#whyFortran">Why Fortran?</a>
if this seems like a questionable decision to you in this modern
world of Matlab, C++, Java, Python, Go, etc.</p></li>
<li><p>Strive to <strong>limit library dependencies</strong>. There is only one required
dependency of DART: netCDF. Many modern systems have 10s or 100s of
dependencies, each of which introduces complexity and the potential
for bugs, lack of support, broken backwards compatibility, etc. If
you’ve ever been frustrated struggling to debug relationships to
packages you’ve never even heard of, you are likely to appreciate
this DART design goal. Of course, there is nothing to stop you from
using whatever dependencies you require, for example, to collect
observations for the <code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code> in an OSE case, but DART by
design will remain separate from that dependency for you and all
other users.</p></li>
<li><p>Only <strong>compile the code you need</strong>. If you are only using a single
model for your experiments, there is no reason to compile or even
touch code for another model you never plan to use. Likewise, if you
are not using a particular observation operator in your experiment,
there is also no need to compile it or let it cause you headaches.
DART recognizes this fact, and through the use of the <em>mkmf</em> utility
and the <em>preprocess</em> program, only what you need will ever be
compiled.</p></li>
<li><p>Use <strong>explicit interfaces</strong> to enforce contract programming. In
practice this means that it is easy to add new models, observations
operators, data assimilation algorithms, etc. as long as they can
implement the required interface. This approach <em>allows all of the
benefits of object-oriented programming without the added complexity
for the end user.</em></p></li>
<li><p>Provide results that are <strong>reliable</strong> and meaningful. The DART
algorithms are carefully tested and maintained in order to be quickly
published along with appropriate analysis. In a world of chaos, being
able to quantify and shrink forecast uncertainty via data
assimilation in a reliable way is a valuable tool for research and
operations and everything in between.</p></li>
</ol>
<p>In short, DART is designed at each step to make it as easy as possible
for users to get up and running with their models, observations, and
possibly even data assimilation algorithm advances.</p>
<p>` &lt;#whyFortran&gt;`__</p>
<div class="section" id="why-fortran">
<h4>Why Fortran?<a class="headerlink" href="#why-fortran" title="Permalink to this headline">¶</a></h4>
<p>Many users new to scientific computing such as graduate students raise
their eyebrows when they first hear that a program uses Fortran for
active development. Fortran is considered by many outside (and some
inside) of the scientific computing community to be a dinosaur, old and
decrepit, and not worthy of serious attention. However, this view is
short-sighted. There is a Chinese idiom 喜新厭舊, which means “to love
the new and loathe the old,” indicating that just because something is
old does not automatically make it bad.</p>
<p>While Fortran does have some outdated features that are far removed from
the mainstream of software engineering (such as implicit typing by first
initial of the variable), these can all be disabled, and the stylistic
rules for easy-to-read, modern Fortran are always followed by DART. On
the other hand, Fortran has many other attractive features that make it
a top choice for modern scientific computing. In particular, Fortran
offers vectorization of matrices that make it possible to operate on
entire elements of an array at once or perform linear algebra operations
on multi-dimensional arrays. With or without the use of the <em>colon
operator</em> (:), Fortran multi-dimensional array support makes
mathematical algorithms easier to read than the equivalent code written
in many other languages. This highly intuitive Fortran syntax was
adopted by Matlab, NumPy, and other languages. Furthermore, for parallel
programs using distributed memory in <em>MPI</em>, Fortran remains a top choice
along with C and C++ when considering performance. Python code, for
example, remains difficult to parallelize via MPI, not to mention the
difficulties in supporting Python 2, Python 3, pip, anaconda,
virtualenv, …</p>
<p>Altogether, for large mathematically-oriented programs that need to be
parallel, Fortran remains a top choice, especially considering the needs
of DART:</p>
<ol class="arabic simple">
<li><p>DART does data assimilation, which is primarily
mathematically-oriented operations on large data sets.</p></li>
<li><p>DART needs to be parallel with MPI to run on modern supercomputers.</p></li>
<li><p>Many users of DART are not software development professionals and
appreciate straightforward and easily understandable code.</p></li>
<li><p>DART source distributions should be easy to compile and run reliably
on many different systems. In practice this means avoiding software
features that might not be supported on all compilers or systems.</p></li>
</ol>
<p>With these considerations in mind, the choice of Fortran for DART
development is clear. DART remains highly successful by keeping things
simple and <em>not fixing what is not broken</em> even if it isn’t shiny and
new.</p>
<p>` &lt;#dartCapabilities&gt;`__</p>
</div>
</div>
<div class="section" id="important-capabilities-of-dart">
<h3>Important capabilities of DART<a class="headerlink" href="#important-capabilities-of-dart" title="Permalink to this headline">¶</a></h3>
<p>In this section we discuss the capabilities of DART that may be of
interest to the user. This is a partial list of all of the functionality
that is available in DART, and additional capabilities and improvements
are continually being added.</p>
<p>As mentioned above, DART allows for both OSSE and OSE systems of models
large and small. This allows users to test both theoretical limits of
DA, models, and observations with idealized experiments as well as to
improve actual real-world forecasts of chaotic systems with real
observations.</p>
<div class="section" id="models-supported-by-dart">
<h4>Models supported by DART<a class="headerlink" href="#models-supported-by-dart" title="Permalink to this headline">¶</a></h4>
<p>A full list of models can be found <a class="reference external" href="Models.md">here</a>, but in brief
the models supported by DART include:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 25%" />
<col style="width: 29%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Model</p></th>
<th class="head"><p>Latest version</p></th>
<th class="head"><p>Model</p></th>
<th class="head"><p>Latest version</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>lorenz_63</p></td>
<td><p>Manhattan</p></td>
<td><p>lorenz_84</p></td>
<td><p>Manhattan</p></td>
</tr>
<tr class="row-odd"><td><p>lorenz_96</p></td>
<td><p>Manhattan</p></td>
<td><p>lorenz_96_2scale</p></td>
<td><p>Manhattan</p></td>
</tr>
<tr class="row-even"><td><p>lorenz_04</p></td>
<td><p>Manhattan</p></td>
<td><p>simple_advection</p></td>
<td><p>Manhattan</p></td>
</tr>
<tr class="row-odd"><td><p>bgrid_solo</p></td>
<td><p>Manhattan</p></td>
<td><p>WRF</p></td>
<td><p>Manhattan</p></td>
</tr>
<tr class="row-even"><td><p>MPAS</p></td>
<td><p>Manhattan</p></td>
<td><p>ATM</p></td>
<td><p>Manhattan</p></td>
</tr>
<tr class="row-odd"><td><p>ROMS</p></td>
<td><p>Manhattan</p></td>
<td><p>CESM</p></td>
<td><p>Manhattan</p></td>
</tr>
<tr class="row-even"><td><p>CAM-FV</p></td>
<td><p>Manhattan</p></td>
<td><p>CAM-CHEM</p></td>
<td><p>Manhattan</p></td>
</tr>
<tr class="row-odd"><td><p>WACCM</p></td>
<td><p>Manhattan</p></td>
<td><p>WACCM-X</p></td>
<td><p>Manhattan</p></td>
</tr>
<tr class="row-even"><td><p>CICE</p></td>
<td><p>Manhattan</p></td>
<td><p>CM1</p></td>
<td><p>Manhattan</p></td>
</tr>
<tr class="row-odd"><td><p>FESOM</p></td>
<td><p>Manhattan</p></td>
<td><p>NOAH-MP</p></td>
<td><p>Manhattan</p></td>
</tr>
<tr class="row-even"><td><p>WRF-Hydro</p></td>
<td><p>Manhattan</p></td>
<td><p>GCCOM</p></td>
<td><p>Lanai</p></td>
</tr>
<tr class="row-odd"><td><p>LMDZ</p></td>
<td><p>Lanai</p></td>
<td><p>MITgcm_ocean</p></td>
<td><p>Lanai</p></td>
</tr>
<tr class="row-even"><td><p>NAAPS</p></td>
<td><p>Lanai</p></td>
<td><p>AM2</p></td>
<td><p>Lanai</p></td>
</tr>
<tr class="row-odd"><td><p>CAM-SE</p></td>
<td><p>Lanai</p></td>
<td><p>CLM</p></td>
<td><p>Lanai</p></td>
</tr>
<tr class="row-even"><td><p>COAMPS</p></td>
<td><p>Lanai</p></td>
<td><p>COSMO</p></td>
<td><p>Lanai</p></td>
</tr>
<tr class="row-odd"><td><p>Dynamo</p></td>
<td><p>Lanai</p></td>
<td><p>GITM</p></td>
<td><p>Lanai</p></td>
</tr>
<tr class="row-even"><td><p>Ikeda</p></td>
<td><p>Lanai</p></td>
<td><p>JULES</p></td>
<td><p>Lanai</p></td>
</tr>
<tr class="row-odd"><td><p>MPAS_ocean</p></td>
<td><p>Lanai</p></td>
<td><p>null_model</p></td>
<td><p>Lanai</p></td>
</tr>
<tr class="row-even"><td><p>openggcm</p></td>
<td><p>Lanai</p></td>
<td><p>PARFLOW</p></td>
<td><p>Lanai</p></td>
</tr>
<tr class="row-odd"><td><p>sqg</p></td>
<td><p>Lanai</p></td>
<td><p>TIE-GCM</p></td>
<td><p>Lanai</p></td>
</tr>
<tr class="row-even"><td><p>WRF-CHEM</p></td>
<td><p>Lanai</p></td>
<td><p>ECHAM</p></td>
<td><p>Prior to Lanai</p></td>
</tr>
<tr class="row-odd"><td><p>PBL_1d</p></td>
<td><p>Prior to Lanai</p></td>
<td><p>MITgcm_annulus</p></td>
<td><p>Prior to Lanai</p></td>
</tr>
<tr class="row-even"><td><p>forced_barot</p></td>
<td><p>Prior to Lanai</p></td>
<td><p>pe2lyr</p></td>
<td><p>Prior to Lanai</p></td>
</tr>
<tr class="row-odd"><td><p>ROSE</p></td>
<td><p>Prior to Lanai</p></td>
<td><p>CABLE</p></td>
<td><p>Prior to Lanai</p></td>
</tr>
</tbody>
</table>
<p>The models listed as “Prior to Lanai” will take some additional work to
integrate with a supported version of DART; please contact the dart &#64;
ucar.edu team for more information. The versions listed as “Lanai” will
be ported to the Manhattan version of DART depending on the needs of the
user community as well as the availablity of resources on the DART team.</p>
<p>` &lt;#obsConverters&gt;`__</p>
</div>
<div class="section" id="observation-converters-provided-by-dart">
<h4>Observation converters provided by DART<a class="headerlink" href="#observation-converters-provided-by-dart" title="Permalink to this headline">¶</a></h4>
<p>Given a way to compute the expected observation value from the model
state, in theory any and all observations can be assimilated by DART
through the <code class="docutils literal notranslate"><span class="pre">obs_seq.out</span></code> file. In practice this means a user-defined
observation converter is required. DART provides many observation
converters to make this process easier for the user. Under the directory
<code class="docutils literal notranslate"><span class="pre">DARTHOME/observations/obs_converters</span></code> there are multiple
subdirectories, each of which has at least one observation converter.
The list of these directories is as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 43%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Observation</p></th>
<th class="head"><p>Directory</p></th>
<th class="head"><p>Format</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://airs.jpl.nasa.gov/">Atmospheric
Infrared
S
ounder</a>
satellite
retrievals</p></td>
<td><p>AIRS</p></td>
<td><p>HDF-EOS</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://www.aviso.altimetry.fr/en/home.html">Aviso</a>:
satellite derived
sea surface height</p></td>
<td><p>Aviso</p></td>
<td><p>netCDF</p></td>
</tr>
<tr class="row-even"><td><p>Level 4 Flux Tower
data from
<a class="reference external" href="http://ameriflux.lbl.gov">A
meriFlux</a></p></td>
<td><p>Ameriflux</p></td>
<td><p>Comma-separated
text</p></td>
</tr>
<tr class="row-odd"><td><p>Level 2 soil
moisture from
<a class="reference external" href="http://cosmos.hwr.arizona.edu/">COSM
OS</a></p></td>
<td><p>COSMOS</p></td>
<td><p>Fixed-width text</p></td>
</tr>
<tr class="row-even"><td><p>Doppler wind lidar</p></td>
<td><p>DWL</p></td>
<td><p>ASCII text</p></td>
</tr>
<tr class="row-odd"><td><p>GPS retrievals of
precipitable water</p></td>
<td><p>GPSPW</p></td>
<td><p>netCDF</p></td>
</tr>
<tr class="row-even"><td><p>GSI observation
file</p></td>
<td><p>GSI2DART</p></td>
<td><p>Fortran binary</p></td>
</tr>
<tr class="row-odd"><td><p>Global
T
emperature-Salinity
Profile Program
(<a class="reference external" href="http://www.nodc.noaa.gov/GTSPP/index.html">GTSPP</a>)</p></td>
<td><p>GTSPP</p></td>
<td><p>netCDF</p></td>
</tr>
<tr class="row-even"><td><p>Meteorological
Assimilation Data
Ingest System
(<a class="reference external" href="http://madis.noaa.gov/">MADIS</a>)</p></td>
<td><p>MADIS</p></td>
<td><p>netCDF</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0273117712001135">MI
DAS</a>
ionospheric obs</p></td>
<td><p>MIDAS</p></td>
<td><p>netCDF</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://modis.gsfc.nasa.gov/">M
ODIS</a>
satellite
retrievals</p></td>
<td><p>MODIS</p></td>
<td><p>Comma-separated
text</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://www.emc.ncep.noaa.gov/mmb/data_processing/prepbufr.doc/document.htm">NCEP
PREPBUFR</a></p></td>
<td><p>NCEP/prep_bufr</p></td>
<td><p>PREPBUFR</p></td>
</tr>
<tr class="row-even"><td><p>NCEP ASCII
observations</p></td>
<td><p>NCEP/ascii_to_obs</p></td>
<td><p>NCEP text files</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://www.myroms.org/">ROMS</a>
verification
observations</p></td>
<td><p>ROMS</p></td>
<td><p>netCDF</p></td>
</tr>
<tr class="row-even"><td><p>Satellite winds
from
<a class="reference external" href="https://www.ssec.wisc.edu/data/">SSE
C</a></p></td>
<td><p>SSEC</p></td>
<td><p>ASCII text</p></td>
</tr>
<tr class="row-odd"><td><p>Sea surface
temperature</p></td>
<td><p>SST</p></td>
<td><p>netCDF</p></td>
</tr>
<tr class="row-even"><td><p>Special Sensor
Ultraviolet
Spectrographic
Imager
(
<a class="reference external" href="https://ssusi.jhuapl.edu/">SSUSI</a>)
retrievals</p></td>
<td><p>SSUSI</p></td>
<td><p>netCDF</p></td>
</tr>
<tr class="row-odd"><td><p>World Ocean
Database
(<a class="reference external" href="http://www.nodc.noaa.gov/OC5/WOD09/pr_wod09.html">W
OD</a>)</p></td>
<td><p>WOD</p></td>
<td><p>World Ocean
Database packed
ASCII</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://nsidc.org/">National Snow and
Ice Data
Center</a>
sea ice obs</p></td>
<td><p>cice</p></td>
<td><p>Binary sea ice</p></td>
</tr>
<tr class="row-odd"><td><p>VTEC
<a class="reference external" href="http://millstonehill.haystack.mit.edu/">Madrigal</a>
upper atmospheric
obs</p></td>
<td><p>gnd_gps_vtec</p></td>
<td><p>ASCII text</p></td>
</tr>
<tr class="row-even"><td><p>GPS obs from
`
COSMIC &lt;<a class="reference external" href="http://www">http://www</a>.
cosmic.ucar.edu&gt;`__</p></td>
<td><p>gps</p></td>
<td><p>netCDF</p></td>
</tr>
<tr class="row-odd"><td><p>Oklahoma
<a class="reference external" href="http://www.mesonet.org/">Mesonet</a>
MDF obs</p></td>
<td><p>ok_mesonet</p></td>
<td><p>Oklahoma Mesonet
MDF files</p></td>
</tr>
<tr class="row-even"><td><p><a href="#id23"><span class="problematic" id="id24">`QuikSCAT &lt;
http://winds.jpl.na
sa.gov/missions/qui
kscat/index.cfm&gt;`__</span></a>
scatterometer winds</p></td>
<td><p>quikscat</p></td>
<td><p>HDF 4</p></td>
</tr>
<tr class="row-odd"><td><p>Radar
reflectivity/radial
velocity obs</p></td>
<td><p>Radar</p></td>
<td><p>WSR-88D (NEXRAD)</p></td>
</tr>
<tr class="row-even"><td><p><a href="#id19"><span class="problematic" id="id20">`</span></a>MODIS Snowcover
Fraction</p>
<blockquote>
<div><p>&lt;<a class="reference external" href="https://modis.gsf">https://modis.gsf</a></p>
</div></blockquote>
<p>c.nasa.gov/data/dat
aprod/mod10.php&gt;`__
obs</p>
</td>
<td><p>snow</p></td>
<td><p>General text</p></td>
</tr>
<tr class="row-odd"><td><p>Text file
(e.g. spreadsheet)
obs</p></td>
<td><p>Text</p></td>
<td><p>General text</p></td>
</tr>
<tr class="row-even"><td><p>Total precipitable
water from AQUA</p></td>
<td><p>tpw</p></td>
<td><p>HDF-EOS</p></td>
</tr>
<tr class="row-odd"><td><p>Automated Tropical
Cyclone Forecast
(<a class="reference external" href="https://www.nrlmry.navy.mil/atcf_web/">ATCF</a>)
obs</p></td>
<td><p>Tropical Cyclones</p></td>
<td><p>Fixed width text</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://www2.mmm.ucar.edu/mm5/On-Line-Tutorial/little_r/little_r.html">LITTLE
_R</a>
obs</p></td>
<td><p>var</p></td>
<td><p>little-r</p></td>
</tr>
<tr class="row-odd"><td><p>`
MM5 &lt;<a class="reference external" href="http://www2.mm">http://www2.mm</a>
m.ucar.edu/mm5/&gt;`__
3D-VAR radar obs</p></td>
<td><p>var</p></td>
<td><p>MM5 3D-VAR 2.0
Radar data files</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="data-assimilation-algorithms-available-in-dart">
<h4>Data assimilation algorithms available in DART<a class="headerlink" href="#data-assimilation-algorithms-available-in-dart" title="Permalink to this headline">¶</a></h4>
<p>DART allows users to test the impact of using multiple different types
of algorithms for filtering, inflation/deflation, and covariance
localization.</p>
<p>DART offers numerous <strong>filter algorithms</strong>. These determine how the
posterior distribution is updated based on the observations and the
prior ensemble. The following table lists the filters supported in DART
along with their type (set by <em>filter_kind</em> in <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> under the
“assim_tools_nml” section):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 37%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Filter #</p></th>
<th class="head"><p>Filter Name</p></th>
<th class="head"><p>References</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>EAKF (Ensemble
Adjustment Kalman
Filter)</p></td>
<td><p><strong>Anderson, J. L.</strong>,
2001. An Ensemble
Adjustment Kalman
Filter for Data
Assimilation. <em>Monthly
Weather Review</em>, 129,
2884-2903.
<a class="reference external" href="https:/">https:/</a>
/doi.org/10.1175/1520-0
493%282001%29129%3C2884
%3AAEAKFF%3E2.0.CO%3B2.
<strong>Anderson, J. L.</strong>,
2003. A local least
squares framework for
ensemble filtering.
<em>Monthly Weather
Review</em>, 131, 634-642.
<a class="reference external" href="https://doi.org/10">https://doi.org/10</a>.
1175/1520-0493%282003%2
9131%3C0634%3AALLSFF%3E
2.0.CO%3B2<strong>Anderson,
J., Collins, N.</strong>,
2007: Scalable
Implementations of
Ensemble Filter
Algorithms for Data
Assimilation. <em>Journal
of Atmospheric and
Oceanic Technology</em>,
24, 1452-1463.
<a class="reference external" href="https://doi">https://doi</a>.
org/10.1175/JTECH2049.1</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>ENKF (Ensemble Kalman
Filter)</p></td>
<td><p><strong>Evensen, G.</strong>, 2003.
The Ensemble Kalman
Filter: Theoretical
Formulation and
Practical
Implementation. <em>Ocean
Dynamics</em>. 53(4),
343–367.
<a class="reference external" href="https://doi.org/10.1">https://doi.org/10.1</a>
007%2Fs10236-003-0036-9</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Kernel filter</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>Observation Space
Particle filter</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Random draw from
posterior</p></td>
<td><p>None. :exclamation:
<em>IMPORTANT</em>: (contact
dart &#64; ucar.edu before
using)</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>Deterministic draw from
posterior with fixed
kurtosis</p></td>
<td><p>None. :exclamation:
<em>IMPORTANT</em>: (contact
dart &#64; ucar.edu before
using)</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>Boxcar kernel filter</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>Rank Histogram filter</p></td>
<td><p><strong>Anderson, J. L.,</strong>
2010. A Non-Gaussian
Ensemble Filter Update
for Data Assimilation.
<em>Monthly Weather
Review</em>, 139,
4186-4198.
<a class="reference external" href="https://doi.or">https://doi.or</a>
g/10.1175/2010MWR3253.1</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>Particle filter</p></td>
<td><p><strong>Poterjoy, J.</strong>, 2016.
A localized particle
filter for
high-dimensional
nonlinear systems.
<em>Monthly Weather
Review</em>, 144 59-76.
<a class="reference external" href="https://doi.org/">https://doi.org/</a>
10.1175/MWR-D-15-0163.1</p></td>
</tr>
</tbody>
</table>
<p>DART also has several <strong>inflation algorithms</strong> available for both prior
(the first value in the namelist) and posterior (the second value in the
namelist). The following table lists the inflation “flavors” supported
in DART along with their type number (set by <em>inf_flavor</em> in
<code class="docutils literal notranslate"><span class="pre">input.nml</span></code> under the “filter_nml” section):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 37%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Flavor #</p></th>
<th class="head"><p>Inflation flavor name</p></th>
<th class="head"><p>References</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>No inflation</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>(Not Supported)</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line">1                | (Not Supported)         | n/a                     |</div>
</div>
<blockquote>
<div><p>Spatially and    |</p>
</div></blockquote>
<div class="line-block">
<div class="line">|                         | temporally varying      |</div>
<div class="line">|                         | adaptive covariance     |</div>
<div class="line">|                         | inflation for ensemble  |</div>
<div class="line">|                         | filters.
<em>Tellus A</em>,   |</div>
<div class="line">|                         | 61, 72-83,              |</div>
<div class="line">|                         | ht                      |</div>
<div class="line">|                         | tps://doi.org/10.1111/j |</div>
<div class="line">|                         | .1600-0870.2008.00361.x |</div>
</div>
<blockquote>
<div><p><em>Tellus A</em>,   |</p>
</div></blockquote>
<div class="line-block">
<div class="line">|                         | 59, 210-224,            |</div>
<div class="line">|                         | ht                      |</div>
<div class="line">|                         | tps://doi.org/10.1111/j |</div>
<div class="line">|                         | .1600-0870.2006.00216.x |</div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 37%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>4</p></td>
<td><p>Relaxation to prior
spread (posterior
inflation only)</p></td>
<td><p><strong>Whitaker, J.S. and
T.M. Hamill</strong>, 2012.
Evaluating Methods to
Account for System
Errors in Ensemble Data
Assimilation. <em>Monthly
Weather Review</em>, 140,
3078–3089,
<a class="reference external" href="https://doi.org/1">https://doi.org/1</a>
0.1175/MWR-D-11-00276.1</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line">|                         | 0.1175/MWR-D-11-00276.1 |</div>
</div>
<blockquote>
<div><p>Enhanced         |</p>
</div></blockquote>
<div class="line-block">
<div class="line">| state-space (inverse    | Adaptive Inflation      |</div>
<div class="line">| gamma)                  | Algorithm for Ensemble  |</div>
<div class="line">|                         | Filters. *</div>
</div>
<p>Monthly      |
|                  |                         | Weather Review*, 2,     |
|                  |                         | 623-640,                |
|                  |                         | <a class="reference external" href="https://doi.org/">https://doi.org/</a>        |
|                  |                         | 10.1175/MWR-D-17-0187.1 |
+——————+————————-+————————-+</p>
<p>DART also offers the ability to correct for sampling errors. DART’s
localization and sampling error correction algorithm is described in &gt; &gt;
<strong>Anderson, J.L.</strong>, 2012. Localization and Sampling Error Correction in
Ensemble Kalman Filter Data Assimilation. <em>Monthly Weather Review</em>, 140,
2359–2371. <a class="reference external" href="https://doi.org/10.1175/MWR-D-11-00013.1">https://doi.org/10.1175/MWR-D-11-00013.1</a></p>
<p>This behavior can be turned on or off via the
<em>sampling_error_correction</em> in <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> under the “assim_tools_nml”
section. The following covariance localization options are available
(set by <em>select_localization</em> in <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> under the
“cov_cutoff_nml” section):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 37%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Loc #</p></th>
<th class="head"><p>Localization type</p></th>
<th class="head"><p>References</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Gaspari-Cohn eq. 4.10</p></td>
<td><p><strong>Gaspari, G. and Cohn,
S. E.</strong>, 1999.
Construction of
correlation functions
in two and three
dimensions. <em>Quarterly
Journal of the Royal
Meteorological
Society</em>, 125, 723-757.
<a class="reference external" href="https://doi.org">https://doi.org</a>
/10.1002/qj.49712555417</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Boxcar</p></td>
<td><p>None</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Ramped boxcar</p></td>
<td><p>None</p></td>
</tr>
</tbody>
</table>
<p>The following image depicts all three of these options:</p>
<p>` &lt;#citeDart&gt;`__</p>
</div>
</div>
<div class="section" id="how-to-cite-dart">
<h3>How to cite DART<a class="headerlink" href="#how-to-cite-dart" title="Permalink to this headline">¶</a></h3>
<p>In order to cite DART, it is appropriate to cite the DART code itself,
which has a doi number, as: The Data Assimilation Research Testbed
(Version X.Y.Z) [Software]. (2019). Boulder, Colorado:
UCAR/NCAR/CISL/DAReS. <a class="reference external" href="http://doi.org/10.5065/D6WQ0202">http://doi.org/10.5065/D6WQ0202</a></p>
<dl class="field-list simple">
<dt class="field-odd">exclamation</dt>
<dd class="field-odd"><p><em>IMPORTANT</em>: Update the DART version and year as</p>
</dd>
</dl>
<p>appropriate.</p>
<p>The seminal reference for DART is:</p>
<blockquote>
<div><p><strong>Anderson, J. L., T. Hoar, K. Raeder, H. Liu, N. Collins, R. Torn
and A. Arellano</strong>, 2009. The Data Assimilation Research Testbed: A
Community Facility. <em>Bulletin of the American Meteorological
Society</em>, 90, 1283-1296, <a class="reference external" href="https://doi.org/10.1175/2009BAMS2618.1">https://doi.org/10.1175/2009BAMS2618.1</a></p>
</div></blockquote>
<p>You should also consider citing the algorithm(s) you are using. The
citations for algorithms are available in <a class="reference external" href="#dartCapabilities">Important capabilities of
DART</a>.</p>
<hr class="docutils" />
<p>` &lt;#RunWithMyModel&gt;`__</p>
</div>
</div>
<div class="section" id="how-do-i-run-dart-with-my-model">
<h2>How do I run DART with my model?<a class="headerlink" href="#how-do-i-run-dart-with-my-model" title="Permalink to this headline">¶</a></h2>
<p>[<a class="reference external" href="#top">top</a>]</p>
<p>In this section, we describe how to add a model to DART. Essentially,
this comes down to implementing a list of required subroutines or using
the default behaviors if appropriate. To cycle more complex models,
additional scripting may be required, especially if the model is run on
a supercomputing queueing system. Refer to your model’s documentation
for more information if necessary.</p>
<p>The following sections cover how to run DART with your model (simple or
complex):</p>
<ol class="arabic simple">
<li><p><cite>Required ``model_mod`</cite> routines &lt;#requiredRoutines&gt;`__</p></li>
<li><p><a class="reference external" href="#simpleModel">Suggestions for a “simple” model</a></p></li>
<li><p><a class="reference external" href="#complexModel">Suggestions for a “complex” model</a></p></li>
<li><p><cite>How to test your ``model_mod`</cite> routines &lt;#howToTestModelMod&gt;`__</p></li>
</ol>
<p>` &lt;#requiredRoutines&gt;`__</p>
<div class="section" id="required-model-mod-routines">
<h3>Required <code class="docutils literal notranslate"><span class="pre">model_mod</span></code> routines<a class="headerlink" href="#required-model-mod-routines" title="Permalink to this headline">¶</a></h3>
<p>There are 18 Fortran subroutines necessary to implement in order to
successfully integrate a model in DART. You will place these routines in
your <code class="docutils literal notranslate"><span class="pre">model_mod.f90</span></code> in a subdirectory with the name of your model in
<code class="docutils literal notranslate"><span class="pre">DARTHOME/models</span></code>. There is often a sensible default implementation
that can be used for each of these routines. For example, in the case of
a model that starts at a time of “0”, for the required routine
<strong>init_time()</strong> the following code will use this default implementation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">use</span> <span class="n">default_model_mod</span><span class="p">,</span>     <span class="n">only</span> <span class="p">:</span> <span class="n">init_time</span>
</pre></div>
</div>
<p>As in all Fortran programs, a comma-separated list of routines can be
listed after the colon.</p>
<dl class="field-list simple">
<dt class="field-odd">exclamation</dt>
<dd class="field-odd"><p><em>IMPORTANT</em>: do not “use” the entire module without the</p>
</dd>
</dl>
<p>keyword “only” in order to avoid including the default behavior for all
subroutines contained in that module (in this example
<code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>).</p>
<p>The following table lists each of the 18 routines, their default modules
relative to <code class="docutils literal notranslate"><span class="pre">DARTHOME</span></code>, and the default behavior. If the default
behavior is not desired, see the section <a class="reference external" href="#simpleModel">How to add a “simple”
model</a> for a model that DART can advance, or <a class="reference external" href="#complexModel">How to
add a “complex” model</a> for a model that is advanced
externally from DART.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 33%" />
<col style="width: 36%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Ro
utine
# /
name</p></th>
<th class="head"><p>Purpose</p></th>
<th class="head"><p>Default module /
directory</p></th>
<th class="head"><p>Default
behavior</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.
<strong>ini
t_tim
e()</strong></p></td>
<td><p>Set the <em>initial
time</em> if not read
from the restart
file.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Sets the
initial time
to 0 days, 0
seconds</p></td>
</tr>
<tr class="row-odd"><td><p>2.
*
<em>init
_cond
ition
s()*</em></p></td>
<td><p>For a “cold start”
fill in an empty
state vector with
<em>initial
conditions</em>. Many
models cannot just
make up values from
thin air and thus
choose to fail when
this is requested.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Sets the
initial
state to 0.
To fail use
<a href="#id21"><span class="problematic" id="id22">``</span></a>init_c
onditions =&gt;</p>
<blockquote>
<div><p>fail_init_c</p>
</div></blockquote>
<p>onditions``.</p>
</td>
</tr>
<tr class="row-even"><td><p>3.
<strong>get
_mode
l_siz
e()</strong></p></td>
<td><p>Return the <em>number
of items in the
state vector</em>.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Returns 1;
i.e. there
is only one
item in the
state.</p></td>
</tr>
<tr class="row-odd"><td><p>4.
<strong>s
tatic
_init
_mode
l()</strong></p></td>
<td><p><em>Initialize</em> DART
with information
about the model that
will be used by the
remaining
<code class="docutils literal notranslate"><span class="pre">model_mod</span></code>
routines. The
procedure for doing
this will depend on
how complex the
model is; see below
for suggestions for
implementation.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Does
nothing.</p></td>
</tr>
<tr class="row-even"><td><p>5.
<strong>g
et_st
ate_
met
a_dat
a()</strong></p></td>
<td><p>Takes an index into
the state vector and
returns the
<em>location</em>
corresponding to
that value and
optionally the
<em>variable type</em>. See
below for
suggestions on
implementation.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Sets a
missing
location and
the default
variable
type.</p></td>
</tr>
<tr class="row-odd"><td><p>6.
<strong>end
_mode
l()</strong></p></td>
<td><p><em>Deallocate</em> any
arrays allocated in
<strong>st
atic_init_model()</strong>.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Does
nothing.</p></td>
</tr>
<tr class="row-even"><td><p>7.
<strong>adv
_1ste
p()</strong></p></td>
<td><p>If possible,
<em>advance the model</em>
state from one time
to another. Complex
models will be
unable to implement
this method and
should fail.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Call the
error
handler with
the message
“unable to
advance
model”.</p></td>
</tr>
<tr class="row-odd"><td><p>short
est_t
ime_
betwe
en_as
simil
ation
s()**</p></td>
<td><p>Return a namelist or
a fixed value for
the <em>minimum model
advance time</em>
between
assimilations. Note
that complex models
will handle
advancing the time
externally.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Returns a
time period
of 1 day.</p></td>
</tr>
<tr class="row-even"><td><p>9.
<strong>m
odel_
inter
polat
e()</strong></p></td>
<td><p><em>Interpolate</em> a
requested quantity
to the given
location to get an
array of expected
values for all
ensemble members.
<em>NOTE</em>: this is
often the most time
consuming method to
implement.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Fail and set
the expected
observation
to
“missing.”</p></td>
</tr>
<tr class="row-odd"><td><p>10.
**
nc_wr
ite_
mode
l_att
s()**</p></td>
<td><p>Add any <em>additional
information</em> to the
netCDF output
diagnostic files.
<em>NOTE</em>: the state
will already be
output by other
routines, so this
method should not
create or write the
state variables.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Does
nothing.</p></td>
</tr>
<tr class="row-even"><td><p>11.
*
<em>read
_mode
l_tim
e()*</em></p></td>
<td><p><em>Read</em> the model
time from a state
vector netCDF file.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">dart_time_io</span></code> /
<code class="docutils literal notranslate"><span class="pre">assimilati</span>
<span class="pre">on_code/io/utilities</span></code></p></td>
<td><p>Attempt to
read the
“time”
variable
from a state
file in an
intelligent
way.</p></td>
</tr>
<tr class="row-odd"><td><p>12.
**
write
_mode
l_tim
e()**</p></td>
<td><p><em>Write</em> the model
time to a state
vector netCDF file.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">dart_time_io</span></code> /
<code class="docutils literal notranslate"><span class="pre">assimilati</span>
<span class="pre">on_code/io/utilities</span></code></p></td>
<td><p>Write the
“time”
variable
from the
file
according to
the DART
calendar.</p></td>
</tr>
<tr class="row-even"><td><p>13.
<strong>p
ert_m
odel_
copie
s()</strong></p></td>
<td><p><em>Perturb</em> a state
vector in order to
create an ensemble.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Add Gaussian
noise with a
specified
amplitude to
all parts of
the state
vector.</p></td>
</tr>
<tr class="row-odd"><td><p>14.
*
<em>conv
ert_
v
ertic
al_ob
s()*</em></p></td>
<td><p>Some 3D models have
multiple vertical
coordinates
(e.g. pressure,
height, or model
level); this method
<em>converts
observations</em>
between different
vertical coordinate
systems.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">location_mod/</span></code>
<code class="docutils literal notranslate"><span class="pre">assimilation_code/</span></code>
<code class="docutils literal notranslate"><span class="pre">location/XXX</span></code></p></td>
<td><p>Do no
conversion.
<em>NOTE</em>:
the
particular
s
ub-directory
of
<code class="docutils literal notranslate"><span class="pre">location</span></code>
to use is
set in
<code class="docutils literal notranslate"><span class="pre">path_names</span>
<span class="pre">_&lt;program&gt;</span></code>
for each
DART
program.</p></td>
</tr>
<tr class="row-even"><td><p>15.
*
<em>conv
ert_
ver
tical
_stat
e()*</em></p></td>
<td><p>Some 3D models have
multiple vertical
coordinates
(e.g. pressure,
height, or model
level); this method
<em>converts state</em>
between different
vertical coordinate
systems.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">location_mod/</span></code>
<code class="docutils literal notranslate"><span class="pre">assimilation_code/</span></code>
<code class="docutils literal notranslate"><span class="pre">location/XXX</span></code></p></td>
<td><p>Do no
conversion.
<em>NOTE</em>:
the
particular
s
ub-directory
of
<code class="docutils literal notranslate"><span class="pre">location</span></code>
to use is
set in
<code class="docutils literal notranslate"><span class="pre">path_names</span>
<span class="pre">_&lt;program&gt;</span></code>
for each
DART
program.</p></td>
</tr>
<tr class="row-odd"><td><p>16.
<strong>ge
t_clo
se_ob
s()</strong></p></td>
<td><p>Calculate <em>which
observations are
“close”</em> to a given
location and,
optionally, the
distance. This is
used for
localization to
reduce sampling
error.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">location_mod/</span></code>
<code class="docutils literal notranslate"><span class="pre">assimilation_code/</span></code>
<code class="docutils literal notranslate"><span class="pre">location/XXX</span></code></p></td>
<td><p>Uses the
default
behavior for
determining
distance.
<em>NOTE</em>:
the
particular
s
ub-directory
of
<code class="docutils literal notranslate"><span class="pre">location</span></code>
to use is
set in
<code class="docutils literal notranslate"><span class="pre">path_names</span>
<span class="pre">_&lt;program&gt;</span></code>
for each
DART
program.</p></td>
</tr>
<tr class="row-even"><td><p>17.
*
<em>get_
close
_stat
e()*</em></p></td>
<td><p>Calculate <em>which
state points are
“close”</em> to a given
location and,
optionally, the
distance. This is
used for
localization to
reduce sampling
error.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">location_mod/</span></code>
<code class="docutils literal notranslate"><span class="pre">assimilation_code/</span></code>
<code class="docutils literal notranslate"><span class="pre">location/XXX</span></code></p></td>
<td><p>Uses the
default
behavior for
determining
distance.
<em>NOTE</em>:
the
particular
s
ub-directory
of
<code class="docutils literal notranslate"><span class="pre">location</span></code>
to use is
set in
<code class="docutils literal notranslate"><span class="pre">path_names</span>
<span class="pre">_&lt;program&gt;</span></code>
for each
DART
program.</p></td>
</tr>
<tr class="row-odd"><td><p>18.
**
nc_wr
ite_
mode
l_var
s()**</p></td>
<td><p>This method is not
currently called, so
just use the default
routine for now.
This method will be
used in a future
implementation.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">default_model_mod</span></code>
/ <code class="docutils literal notranslate"><span class="pre">models/utilities</span></code></p></td>
<td><p>Does
nothing.</p></td>
</tr>
</tbody>
</table>
<p>` &lt;#simpleModel&gt;`__</p>
</div>
<div class="section" id="suggestions-for-a-simple-model">
<h3>Suggestions for a “simple” model<a class="headerlink" href="#suggestions-for-a-simple-model" title="Permalink to this headline">¶</a></h3>
<p>A “simple” model is one where DART can advance the model through a
function call. As we saw above, Lorenz 63 falls into this category and
can be used as a reference. Here we provide some further advice on how
to add this kind of model to DART.</p>
<p>The primary consideration with a simple model is how you will store the
state. If you have only a <em>single type of variable</em> in your state vector
(for example, the Lorenz 63 model), here are some hints on how to
implement your initialization and meta data routines:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Routine # /
name</p></th>
<th class="head"><p>Suggested implementation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>4.
<strong>static_init_
model()</strong></p></td>
<td><p>Your model_size will likely be set by namelist, so
read it, allocate an array of that size, and
precompute all the locations for each state vector
item. Call <strong>add_domain()</strong> with the model size so
DART knows how long the state vector is.</p></td>
</tr>
<tr class="row-odd"><td><p>5.
<strong>get_state_
meta_data()</strong></p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">QTY_STATE_VARIABLE</span></code> as the quantity, and
return the location for that index through a
look-up into the location array created during
<strong>static_init_ model()</strong>.</p></td>
</tr>
</tbody>
</table>
<p>If you have <em>more than a single type of variable</em> in the state vector
(for example, “concentration”, “wind”, etc. as in the
<code class="docutils literal notranslate"><span class="pre">DARTHOME/models/simple_advection</span></code> model):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Routine # /
name</p></th>
<th class="head"><p>Suggested implementation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>4.
<strong>static_init_
model()</strong></p></td>
<td><p>Read from the namelist the number of fields to be
used in the state vector. Use <strong>add_domain()</strong> to
indicate which netCDF vars should be read. Read in
any auxiliary data needed by interpolation code
(for example, the grid topology). Cache the grid
locations of the state variables as appropriate,
and use <strong>get_domain_size()</strong> to compute the
model_size.</p></td>
</tr>
<tr class="row-odd"><td><p>5.
<strong>get_state_
meta_data()</strong></p></td>
<td><p>Call <strong>get_model_variable_indices()</strong> and
<strong>get_state_kind()</strong> to figure out the
(<em>i</em>,<em>j</em>,<em>k</em>) indices and which variable this
offset is. Use the (<em>i</em>,<em>j</em>,<em>k</em>) index to
compute the grid location and return it along with
the quantity.</p></td>
</tr>
</tbody>
</table>
<p>Now, for either type of simple model, the following applies:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Routine # /
name</p></th>
<th class="head"><p>Suggested implementation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>6.
<strong>end_model()</strong></p></td>
<td><p>Deallocate any arrays allocated in
<strong>static_init_model()</strong></p></td>
</tr>
<tr class="row-odd"><td><p>7.
<strong>adv_1step()</strong></p></td>
<td><p>If possible, embed the code that computes
<strong>x</strong>(<em>t</em>+1) = <strong>F</strong>(<strong>x</strong>(<em>t</em>)) or call a
separate subroutine to advance the model state
from one time to another.</p></td>
</tr>
<tr class="row-even"><td><p>shortest_time_
between_as
similations()**</p></td>
<td><p>Return a namelist or a fixed value for the minimum
model advance time.</p></td>
</tr>
<tr class="row-odd"><td><p>9.
<strong>model_
interpolate()</strong></p></td>
<td><p>Find the indices which enclose that location and
interpolate to get an array of expected values.</p></td>
</tr>
<tr class="row-even"><td><p>10.
<strong>nc_write
_model_atts()</strong></p></td>
<td><p>Optionally add any desired attributes to the
output diagnostic files.</p></td>
</tr>
</tbody>
</table>
<p>The remaining routines can mostly use the defaults, except possibly for
11. <strong>read_model_time()</strong> and 12. <strong>write_model_time()</strong>, which may need
to be customized if using a model restart file that already stores time
in a particular format.</p>
<p>Note that there is often no need to convert vertical obs or states in a
simple model without vertical coordinate choices.</p>
<p>` &lt;#complexModel&gt;`__</p>
</div>
<div class="section" id="suggestions-for-a-complex-model">
<h3>Suggestions for a “complex” model<a class="headerlink" href="#suggestions-for-a-complex-model" title="Permalink to this headline">¶</a></h3>
<p>A “complex” model is typically a large geophysical model where the model
must be advanced outside of DART execution control. Here we provide some
advice on how to integrate this kind of model with DART.</p>
<p>First of all, the 4. <strong>static_init_model</strong>, 5. <strong>get_state_meta_data()</strong>
and 6. <strong>end_model()</strong> suggestions will match the multiple state
variable in the previous section as complex models will typically have
multiple fields.</p>
<p>An additional twist is that complex models may have different grid
locations for different variables, (i.e. grid staggering), but the above
instructions still apply.</p>
<p>The 7. <strong>adv_1step()</strong> method for a complex model should fail, so the
default behavior is sufficient.</p>
<p>The advice for the 8. <strong>shortest_time_between_assimilations()</strong> routine
is similar to the advice for a simple model: read the value from the
namelist or return a fixed time as appropriate.</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: since the model will not be advanced by DART, the value</p>
</dd>
</dl>
<p>returned here is irrelevant except for user information purposes.</p>
<p>For the remaining routines, we give the following implementation
suggestions:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Routine # /
name</p></th>
<th class="head"><p>Suggested implementation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>9. <strong>model_
interpolate()</strong></p></td>
<td><p>Find the (<em>i</em>,<em>j</em>,<em>k</em>) indices which enclose
that location, or search for the cell number. For
some models you can compute (<em>i</em>,<em>j</em>) directly
from a regular lat/lon grid, and in others you may
have to search over a deformed grid. Any model
code or utilities available for this purpose may
prove very helpful as a starting point. In the
end, you will use <strong>get_state()</strong> to retrieve an
ensemble-sized array of values for each offset
into the state vector, and then do interpolation
to get an array of expected values.</p></td>
</tr>
<tr class="row-odd"><td><p>10.
<strong>nc_write_
model_atts()</strong></p></td>
<td><p>It is very helpful (but optional) to add grid
information to assist in plotting your results.</p></td>
</tr>
<tr class="row-even"><td><p>11.
<strong>read_model_
time()</strong></p></td>
<td><p>(see <strong>write_model_time()</strong> below)</p></td>
</tr>
<tr class="row-odd"><td><p>12.
<strong>write_model_
time()</strong></p></td>
<td><p>If the model time is stored in the netCDF files,
supply routines that can read and write it in the
correct format. The default routines will work if
the model time matches what those routines expect:
a time variable with an optional calendar
variable. If no calendar is provided, the routine
assumes fractional days. If the time variable is
an array (i.e. more than one time step is stored
in the file), read/write the last one.</p></td>
</tr>
<tr class="row-even"><td><p>13.
<strong>pert_model_
copies()</strong></p></td>
<td><p>The default of adding Gaussian noise to all state
variables may be undesirable. Complex models often
have a method to perturb a state according to a
particular formula or method. Otherwise, it may be
necessary to perturb each variable with separate
noise levels, only perturb certain variables, etc.</p></td>
</tr>
<tr class="row-odd"><td><p>14. <strong>convert_
v
ertical_obs()</strong></p></td>
<td><p>(see <strong>convert_vertical_state()</strong> below)</p></td>
</tr>
<tr class="row-even"><td><p>15. <strong>convert_
ver
tical_state()</strong></p></td>
<td><p>Add code to convert between vertical coordinates
(e.g. pressure, height, sigma levels, etc.) if
appropriate. Code from the model or a model
utility may be a very helpful starting point.</p></td>
</tr>
<tr class="row-odd"><td><p>16.
<strong>get_close_
obs()</strong></p></td>
<td><p>(see <strong>get_close_state()</strong> below)</p></td>
</tr>
<tr class="row-even"><td><p>17.
<strong>get_close_
state()</strong></p></td>
<td><p>If you want to change the localization impact
based on something other than the type or kind,
put code here. You should test for vertical type
and do the conversion on demand if it hasn’t
already been done.</p></td>
</tr>
</tbody>
</table>
<p>As mentioned above, the most difficult routine to implement for a
complex model is typically 9. <strong>model_interpolate()</strong>.</p>
<p>` &lt;#howToTestModelMod&gt;`__</p>
</div>
<div class="section" id="how-to-test-your-model-mod-routines">
<h3>How to test your <code class="docutils literal notranslate"><span class="pre">model_mod</span></code> routines<a class="headerlink" href="#how-to-test-your-model-mod-routines" title="Permalink to this headline">¶</a></h3>
<p>The program <code class="docutils literal notranslate"><span class="pre">model_mod_check.f90</span></code> can be used to test the routines
individually before running them with <em>filter</em>. Add a
<code class="docutils literal notranslate"><span class="pre">mkmf_model_mod_check</span></code> and <code class="docutils literal notranslate"><span class="pre">path_names_model_mod_check</span></code> to your
<code class="docutils literal notranslate"><span class="pre">DARTHOME/models/your_model/work</span></code> subdirectory. You might find it
helpful to consult another model matching your model type (simple or
complex). See the documentation for <code class="docutils literal notranslate"><span class="pre">model_mod_check</span></code> in
<code class="docutils literal notranslate"><span class="pre">DARTHOME/assimilation_code/programs/model_mod_check</span></code> for more
information on the tests available.</p>
<hr class="docutils" />
<p>` &lt;#RunWithMyObs&gt;`__</p>
</div>
</div>
<div class="section" id="how-do-i-add-my-observations-to-dart">
<h2>How do I add my observations to DART?<a class="headerlink" href="#how-do-i-add-my-observations-to-dart" title="Permalink to this headline">¶</a></h2>
<p>[<a class="reference external" href="#top">top</a>]</p>
<p>First, you should understand that DART already supports a tremendous
variety of observations. To fully support an observation means that the
observation can be converted from its native format to the DART
observation sequence format and that the observation forward operator is
already implemented. Keep in mind that forward operators are not
specific to any one model.</p>
<p>The observation converters are in the <em>observations/obs_converter</em>
directory and you should look there for the documentation describing
which converters are available.</p>
<p>The forward operators are functionally or logically grouped into Fortran
modules in the <em>observations/forward_operator</em> directory. DART employs a
‘contractual’ style of programming in that the forward operator requests
information from the model, and if the model cannot provide it, the
forward operator may request different information in an attempt to
collect the information needed to apply the operator. If the model
cannot provide any of the required information, the forward operator
fails, the DART QC for that observation is set to the appropriate value,
and the program continues.</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="#obsBackground">Background on DART observations</a></p></li>
<li><p><a class="reference external" href="#newQUANTITIES">Adding new observation quantities</a></p></li>
<li><p><a class="reference external" href="#newTYPES">Adding new observation types</a></p></li>
<li><p><a class="reference external" href="#simpleObs">‘Simple’ observation support</a></p></li>
<li><p><a class="reference external" href="#complexObs">More complex observations</a></p></li>
<li><p><a class="reference external" href="#exampleObsDef">Example observation definition</a></p></li>
<li><p><a class="reference external" href="#obsSeqFile">Observation sequence file</a></p></li>
</ol>
<p>` &lt;#obsBackground&gt;`__ ### Background on DART observations</p>
<p>The Iceland release of DART added a powerful and flexible mechanism to
generate the core observation operator code using the <em>preprocess</em>
program. The use of the <em>preprocess</em> program was covered above in
<a class="reference external" href="#building">Building the Lorenz_63 DART project</a> and <a class="reference external" href="#dartWorkflow">High-level DA
workflows in DART</a>, so it is assumed you are familiar
with the basic workings of the <em>preprocess</em> program before continuing.</p>
<p>To add your own observation support, you will need to create an
<em>observation definition</em>. The DART Fortran90 derived type <em>obs_def</em>
provides an abstraction of the definition of an observation. At a higher
level, an <em>observation sequence</em> (<em>obs_seq</em>) is composed of observation
definitions associated with observed values. The basic operations
required to implement an observation definition are an ability to
compute a forward operator given the model state vector, the ability to
read/write the observation definition from/to a file, and a capability
to do a standard input driven interactive definition of the observation
definition.</p>
<p>DART makes a further distinction between specific <em>observation types</em>
and generic <em>quantities</em>. Essentially, an <em>observation type</em> can be
considered to be instrument-specific and the <em>quantity</em> is something you
learned about in physics. As an example, ‘RADIOSONDE_TEMPERATURE’ is an
<em>observation type</em> of the fundamental <em>quantity</em> ‘TEMPERATURE’. The role
of the various obs_def input files is to define the mapping between the
types and quantities, and optionally to provide type-specific processing
routines. Specifying many observation types allows DART to be able to
evaluate some observations and assimilate others - even if the
instruments measure the same <em>quantity</em>.</p>
<p>A single obs_def output module is created by the program <em>preprocess</em>
from two kinds of input files. First, a DEFAULT obs_def module (normally
called <code class="docutils literal notranslate"><span class="pre">DEFAULT_obs_def_mod.F90</span></code> and documented in the
<code class="docutils literal notranslate"><span class="pre">DARTHOME/observations/forward_operators</span></code> directory) is used as a
template into which the preprocessor incorporates information from zero
or more special obs_def modules (for example,
<code class="docutils literal notranslate"><span class="pre">obs_def_1d_state_mod.f90</span></code> or <code class="docutils literal notranslate"><span class="pre">obs_def_reanalysis_bufr_mod.f90</span></code>) as
documented in the <code class="docutils literal notranslate"><span class="pre">DARTHOME/observations/forward_operators</span></code> directory.
If no special obs_def files are included in the preprocessor namelist, a
minimal <code class="docutils literal notranslate"><span class="pre">obs_def_mod.f90</span></code> is created which can only support identity
forward observation operators.</p>
<p>` &lt;#newQUANTITIES&gt;`__ #### Adding a new observation <em>quantity</em></p>
<p>The
<code class="docutils literal notranslate"><span class="pre">DARTHOME/assimilation_code/modules/observations/DEFAULT_obs_kind_mod.F90</span></code>
file must be edited to include a unique integer identifier for the
quantity. There are two, sometimes three places in the file that require
modification. The first is in the table of existing NAME-value pairs and
the second is perhaps halfway down the file in the section after:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! DART PREPROCESS OBS_QTY_INFO INSERTED HERE
</pre></div>
</div>
<p>If you add an observation quantity with an integer value greater than
<strong>max_defined_quantities</strong>, make sure you increase
<em>max_defined_quantities</em>.</p>
<p>` &lt;#newTYPES&gt;`__ #### Adding a new observation <em>type</em></p>
<p>The observation support modules are in the
<code class="docutils literal notranslate"><span class="pre">DARTHOME/observations/forward_operators</span></code> directory. If the
observation type logically belongs in an existing observation module, it
should be fairly obvious how to add support for a new observation type.
Feel free to use ideas from other modules - look around!</p>
<p>To add a new observation <em>type</em> which does not fit into any of the
already-defined obs_def files, a new file should be created in the
<code class="docutils literal notranslate"><span class="pre">DARTHOME/observations/forward_operators</span></code> directory. These files are
usually named according the the pattern <code class="docutils literal notranslate"><span class="pre">obs_def_X_mod.f90</span></code>, where the
<em>X</em> is either an instrument name, a data source, or a class of
observations. See the existing filenames in that directory for ideas.
This new obs_def filename must then be listed in the <code class="docutils literal notranslate"><span class="pre">input.nml</span></code>
namelist for the model in the <em>&amp;preprocess_nml</em> section in the
<em>input_files</em> namelist variable. This variable is a string list type
which can contain multiple obs_def filenames. Running the preprocess
program will then use the contents of the new obs_def file to generate
the needed output files for use in linking to the rest of the DART
system. <em>If the new observation type also requires a new observation
quantity, there is more work to be done.</em> Please see the list of
available observation quantities in
<code class="docutils literal notranslate"><span class="pre">assimilation_code/modules/observations/DEFAULT_obs_kind_mod.f90</span></code> to
determine if an existing observation quantity is appropriate.</p>
<p>` &lt;#simpleObs&gt;`__ ### ‘Simple’ observation support</p>
<p>If the new observation type can be directly interpolated by the
<em>model_mod</em> <strong>model_interpolate()</strong> interpolation routine (see <cite>Required
``model_mod`</cite> routines &lt;#requiredRoutines&gt;`__ for more information) and
has no additional observation-specific code for reading, writing, or
initializing the observation, then the entire contents of the new file
is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS KIND LIST
! type, quantity, COMMON_CODE
! (repeat lines for each type)
! END DART PREPROCESS KIND LIST
</pre></div>
</div>
<p>DART will automatically generate all the interface code needed for these
new observation types through <em>preprocess</em>. For example, here is a real
list of observation types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS KIND LIST
!VELOCITY,                     QTY_VELOCITY,              COMMON_CODE
!TRACER_CONCENTRATION,         QTY_TRACER_CONCENTRATION,  COMMON_CODE
!TRACER_SOURCE,                QTY_TRACER_SOURCE,         COMMON_CODE
!MEAN_SOURCE,                  QTY_MEAN_SOURCE,           COMMON_CODE
!OI_SEA_SURFACE_TEMPERATURE,   QTY_TEMPERATURE,           COMMON_CODE
! END DART PREPROCESS KIND LIST
</pre></div>
</div>
<p>The first column is the specific observation type and should be unique.
The second column is the generic quantity and must match the list of
known quantities in <code class="docutils literal notranslate"><span class="pre">obs_kind_mod.f90</span></code>. The first and second column
often match, but as shown in the last line this need not be the case.
The third column must be the keyword COMMON_CODE which tells the
preprocess program to automatically generate all necessary interface
code for this type. COMMON_CODE also implicitly means the
“model_interpolate()” routine is used as the forward operator.</p>
<p>` &lt;#complexObs&gt;`__ ### Obs definitions for observations needing special
handling</p>
<p>For observation types which have observation-specific routines, or must
interpolate using a combination of other generic quantities, or require
additional observation-specific data to compute, the following format is
used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS KIND LIST
! type, quantity
! (repeat lines for each type/quantity pair)
! END DART PREPROCESS KIND LIST
</pre></div>
</div>
<p>DART will need user-supplied interface code for each of the listed
types. For example, here is a real list without “COMMON_CODE” in the
third column:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS KIND LIST
! DOPPLER_RADIAL_VELOCITY, QTY_VELOCITY
! RADAR_REFLECTIVITY,      QTY_RADAR_REFLECTIVITY
! END DART PREPROCESS KIND LIST
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: the difference between the simple obs_def case is the</p>
</dd>
</dl>
<p>lack of COMMON_CODE in the third column.</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: if interested, you can reference the</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">obs_def_wind_speed_mod.f90</span></code> “get_expected_wind_speed()” function for
an example of a non-COMMON_CODE observation type. The operator is in the
<code class="docutils literal notranslate"><span class="pre">DARTHOME/observations/forward_operators</span></code> directory.</p>
<p>In the non-COMMON_CODE case, DART needs additional information for how
to process the observation type. This will include code sections
delimited by precisely formatted comments, and possibly module code
sections. This code will be combined by <em>preprocess</em> to make a single
observation definition file with only the desired observations. There
are six such locations within <code class="docutils literal notranslate"><span class="pre">obs_def_XXX.f90</span></code> where a new forward
operator should make changes to meet the interface of obs_def.</p>
<dl class="field-list simple">
<dt class="field-odd">exclamation</dt>
<dd class="field-odd"><p><em>IMPORTANT:</em> as the code in these six comment sections</p>
</dd>
</dl>
<p>will be automatically combined with the code of other observation
definitions, the majority of the forward operator code should be defined
inside a separate module to keep variables and other private subroutines
from colliding with unrelated routines and variables in other forward
operator files. In other words, the code in the sections below should
primarily call procedures from a separate module you define.</p>
<p>There are six sections of code inserted into the <code class="docutils literal notranslate"><span class="pre">DEFAULT_obs_def_mod</span></code>
for each of the obs_def modules that are requested. These are:</p>
<p><em>preprocess</em> automatically collects and combines the <em>use</em> statements in
all observations definitions through the following comment block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS USE OF SPECIAL OBS_DEF MODULE
! END DART PREPROCESS USE OF SPECIAL OBS_DEF MODULE
</pre></div>
</div>
<p>Any Fortran use statements for public subroutines or variables from
other modules should be placed between these lines, with comment
characters in the first column.</p>
<p>For example, if the forward operator code includes a module with public
routines then a “use” statement like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">use</span> <span class="n">obs_def_1d_state_mod</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">write_1d_integral</span><span class="p">,</span> <span class="n">read_1d_integral</span><span class="p">,</span> <span class="o">&amp;</span>
                                 <span class="n">interactive_1d_integral</span><span class="p">,</span> <span class="n">get_expected_1d_integral</span>
</pre></div>
</div>
<p>needs to be added to your <code class="docutils literal notranslate"><span class="pre">obs_def_mod</span></code> so the listed subroutines are
available to be called. This would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS USE OF SPECIAL OBS_DEF MODULE
! use obs_def_1d_state_mod, only : write_1d_integral, read_1d_integral, &amp;
!                                  interactive_1d_integral, get_expected_1d_integral
! END DART PREPROCESS USE OF SPECIAL OBS_DEF MODULE
</pre></div>
</div>
<p><em>preprocess</em> collects and combines the <em>obs processing</em> code for all
observations definitions through the following comment block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS GET_EXPECTED_OBS_FROM_DEF
! END DART PREPROCESS GET_EXPECTED_OBS_FROM_DEF
</pre></div>
</div>
<p>These comments must enclose a case statement for each defined type that
returns the expected observation value based on the current values of
the state vector. The code must be in comments, with the comment
character in the first column.</p>
<p>The variables available to be passed to subroutines or used in this
section of code are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 21%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable name</p></th>
<th class="head"><p>Intent</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>state_handle</p></td>
<td><p>In</p></td>
<td><p>A handle to access the
state vector (including
all ensemble members)</p></td>
</tr>
<tr class="row-odd"><td><p>ens_size</p></td>
<td><p>In</p></td>
<td><p>The number of ensemble
members to operate on
(between 1 and total
ensemble size)</p></td>
</tr>
<tr class="row-even"><td><p>copy_indices</p></td>
<td><p>In</p></td>
<td><p>The indices the ensemble
members (between 1 and
total ensemble size)</p></td>
</tr>
<tr class="row-odd"><td><p>location</p></td>
<td><p>In</p></td>
<td><p>The observation location</p></td>
</tr>
<tr class="row-even"><td><p>obs_type_ind</p></td>
<td><p>In</p></td>
<td><p>The index of the specific
type of observation</p></td>
</tr>
<tr class="row-odd"><td><p>obs_time</p></td>
<td><p>In</p></td>
<td><p>The time of the
observation</p></td>
</tr>
<tr class="row-even"><td><p>error_var</p></td>
<td><p>In</p></td>
<td><p>The observation error
variance</p></td>
</tr>
<tr class="row-odd"><td><p>isprior</p></td>
<td><p>In</p></td>
<td><p><em>true</em> for prior eval;
<em>false</em> for posterior</p></td>
</tr>
</tbody>
</table>
<p>The routine must fill in the values of these variables:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 22%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable name</p></th>
<th class="head"><p>Intent</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>expected_obs</p></td>
<td><p>Out</p></td>
<td><p>The computed forward
operator values
(between 1 and
ens_size)</p></td>
</tr>
<tr class="row-odd"><td><p>istatus</p></td>
<td><p>Out</p></td>
<td><p>Return code: 0=ok, &gt;0
is error, &lt;0 reserved
for system use</p></td>
</tr>
</tbody>
</table>
<p>To call a model_mod interpolate routine directly, the argument list must
match exactly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interpolate</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">QTY_xxx</span><span class="p">,</span> <span class="n">obs_val</span><span class="p">,</span> <span class="n">istatus</span><span class="p">)</span>
</pre></div>
</div>
<p>with the <em>xxx</em> replaced with the correct quantity.</p>
<p>This can be useful if the forward operator needs to retrieve values for
fields which are typically found in a model and then compute a derived
value from them.</p>
<p><em>preprocess</em> collects and combines the code to <em>read the observation
metadata</em> for all observations definitions through the following comment
block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS READ_OBS_DEF
! END DART PREPROCESS READ_OBS_DEF
</pre></div>
</div>
<p>These comments must enclose a case statement for each defined type that
reads any additional data associated with a single observation. If there
is no information beyond that for the basic obs_def type, the case
statement must still be provided, but the code can simply be “continue”.
The code must be in comments, with the comment character in the first
column.</p>
<p>The variables available to be passed to subroutines or used in this
section of code are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 35%" />
<col style="width: 32%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable name</p></th>
<th class="head"><p>Intent</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ifile</p></td>
<td><p>In</p></td>
<td><p>The open unit number
positioned ready to
read</p></td>
</tr>
<tr class="row-odd"><td><p>obs_def</p></td>
<td><p>Inout</p></td>
<td><p>The rest of the
<em>obs_def</em> derived
type for this obs</p></td>
</tr>
<tr class="row-even"><td><p>key</p></td>
<td><p>In</p></td>
<td><p>The index
observation number
in this sequence
(read-only)</p></td>
</tr>
<tr class="row-odd"><td><p>obs_val</p></td>
<td><p>In</p></td>
<td><p>The observation
value, if needed</p></td>
</tr>
<tr class="row-even"><td><p>is_ascii</p></td>
<td><p>In</p></td>
<td><p>Logical to indicate
how the file was
opened, formatted or
unformatted</p></td>
</tr>
</tbody>
</table>
<p>The usual use of this routine is to read in additional metadata per
observation and to set the private key in the obs_def to indicate the
metadata index to use for this observation. Do not confuse the key in
the obs_def with the key argument to this routine; the latter is the
global observation sequence number for this observation.</p>
<p><em>preprocess</em> collects and combines the code to <em>write the observation
metadata</em> for all observations definitions through the following comment
block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS WRITE_OBS_DEF
! END DART PREPROCESS WRITE_OBS_DEF
</pre></div>
</div>
<p>These comments must enclose a case statement for each defined type that
writes any additional data associated with a single observation. If
there is no information beyond that for the basic obs_def type, the case
statement must still be provided, but the code can simply be “continue.”
The code must be in comments, with the comment character in the first
column.</p>
<p>The variables available to be passed to subroutines or used in this
section of code are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 22%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable name</p></th>
<th class="head"><p>Intent</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ifile</p></td>
<td><p>In</p></td>
<td><p>The open unit number
positioned ready to
write</p></td>
</tr>
<tr class="row-odd"><td><p>obs_def</p></td>
<td><p>In</p></td>
<td><p>The rest of the obs_def
derived type for this
obs</p></td>
</tr>
<tr class="row-even"><td><p>key</p></td>
<td><p>In</p></td>
<td><p>The index observation
number in this sequence</p></td>
</tr>
<tr class="row-odd"><td><p>is_ascii</p></td>
<td><p>In</p></td>
<td><p>A logical value to
indicate how the file
was opened, formatted
or unformatted</p></td>
</tr>
</tbody>
</table>
<p>The usual use of this routine is to write the additional metadata for
this observation based on the private key in the obs_def. Do not confuse
this with the key in the subroutine call which is the observation number
relative to the entire observation sequence file.</p>
<p><em>preprocess</em> collects and combines the code to <em>read input from the user
for the observation metadata</em> for all observations definitions through
the following comment block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS INTERACTIVE_OBS_DEF
! END DART PREPROCESS INTERACTIVE_OBS_DEF
</pre></div>
</div>
<p>These comments must enclose a case statement for each defined type that
prompts the user for any additional data associated with a single
observation. If there is no information beyond that for the basic
obs_def type, the case statement must still be provided, but the code
can simply be continue. The code must be in comments, with the comment
character in the first column.</p>
<p>The variables available to be passed to subroutines or used in this
section of code are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 9%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable name</p></th>
<th class="head"><p>Intent</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>obs_def</p></td>
<td><p>Inout</p></td>
<td><p>The rest of the obs_def derived type for this obs.</p></td>
</tr>
<tr class="row-odd"><td><p>key</p></td>
<td><p>In</p></td>
<td><p>The index observation number in this sequence.</p></td>
</tr>
</tbody>
</table>
<p>The DART code will prompt for the rest of the obs_def values (location,
type, value, error) but any additional metadata needed by this
observation type should be prompted to, and read from, the console
(e.g. write(<em>,</em>), and read(<em>,</em>)). The code will generally set the
obs_def%key value as part of setting the metadata.</p>
<p><em>preprocess</em> collects and combines the code to <em>preprocess the
observation</em> for all observations definitions through the following
comment block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS MODULE CODE
! END DART PREPROCESS MODULE CODE
</pre></div>
</div>
<p>If the code to process this observation requires module data and/or
subroutines, then these comments must surround the module definitions.
Unlike all the other sections, this comment pair is <em>optional,</em> and if
used, the code must <strong>not</strong> be in comments; it will be copied verbatim
over to the output file.</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: the “preprocess” here is for processing specific</p>
</dd>
</dl>
<p>observations and should not be confused with the <em>preprocess</em> program
that generates the observation Fortran code.</p>
<p>` &lt;#exampleObsDef&gt;`__</p>
<div class="section" id="example-observation-definition">
<h3>Example observation definition<a class="headerlink" href="#example-observation-definition" title="Permalink to this headline">¶</a></h3>
<p>This section contains an example observation definition file. As shown
here, it is possible to mix automatic code types and user-supplied code
types in the same list. Simply add the COMMON_CODE keyword on the lines
which need no special data or interfaces. For example, here is an
extract from the 1d state obs_def module, where the raw state variable
needs only autogenerated code, but the 1d integral has user-supplied
processing code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! BEGIN DART PREPROCESS KIND LIST
! RAW_STATE_VARIABLE,    QTY_STATE_VARIABLE, COMMON_CODE
! RAW_STATE_1D_INTEGRAL, QTY_1D_INTEGRAL
! END DART PREPROCESS KIND LIST


! BEGIN DART PREPROCESS USE OF SPECIAL OBS_DEF MODULE
!   use obs_def_1d_state_mod, only : write_1d_integral, read_1d_integral, &amp;
!                                    interactive_1d_integral, get_expected_1d_integral
! END DART PREPROCESS USE OF SPECIAL OBS_DEF MODULE

! BEGIN DART PREPROCESS GET_EXPECTED_OBS_FROM_DEF
!         case(RAW_STATE_1D_INTEGRAL)
!            call get_expected_1d_integral(state, location, obs_def%key, obs_val, istatus)
! END DART PREPROCESS GET_EXPECTED_OBS_FROM_DEF

! BEGIN DART PREPROCESS READ_OBS_DEF
!      case(RAW_STATE_1D_INTEGRAL)
!         call read_1d_integral(obs_def%key, ifile, fileformat)
! END DART PREPROCESS READ_OBS_DEF

! BEGIN DART PREPROCESS WRITE_OBS_DEF
!      case(RAW_STATE_1D_INTEGRAL)
!         call write_1d_integral(obs_def%key, ifile, fileformat)
! END DART PREPROCESS WRITE_OBS_DEF

! BEGIN DART PREPROCESS INTERACTIVE_OBS_DEF
!      case(RAW_STATE_1D_INTEGRAL)
!         call interactive_1d_integral(obs_def%key)
! END DART PREPROCESS INTERACTIVE_OBS_DEF

! BEGIN DART PREPROCESS MODULE CODE
module obs_def_1d_state_mod

use        types_mod, only : r8
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG
use     location_mod, only : location_type, set_location, get_location
use  assim_model_mod, only : interpolate
use   cov_cutoff_mod, only : comp_cov_factor

implicit none

public :: write_1d_integral, read_1d_integral, interactive_1d_integral, &amp;
         get_expected_1d_integral

...  (module code here)

end module obs_def_1d_state_mod
! END DART PREPROCESS MODULE CODE
</pre></div>
</div>
<p>See the <code class="docutils literal notranslate"><span class="pre">obs_def_1d_state_mod.f90</span></code> documentation for more details and
examples of each section. Also see <code class="docutils literal notranslate"><span class="pre">obs_def_wind_speed_mod.f90</span></code>
“get_expected_wind_speed()” for an example of a 3D geophysical forward
operator. Both operators are in the
<code class="docutils literal notranslate"><span class="pre">DARTHOME/observations/forward_operators</span></code> directory.</p>
<p>` &lt;#obsSeqFile&gt;`__</p>
</div>
<div class="section" id="observation-sequence-file-creation">
<h3>Observation sequence file creation<a class="headerlink" href="#observation-sequence-file-creation" title="Permalink to this headline">¶</a></h3>
<p>DART uses an <em>observation sequence</em> file that contains the observations
to be assimilated. An <em>observation converter</em> will convert observations
from the native observation format into this DART-specific format.
Ultimately, it is the user’s responsibility to convert the observations,
but there are many helper tools and utilities to make this process
easier.</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: the observation sequence file can be written in either</p>
</dd>
</dl>
<p>human- readable ASCII or machine-readable binary. The binary
representation will use approximately two times less disk space, but the
ASCII representation makes manually inspecting the file contents much
easier. For either representation, the underlying data is the same.
There is a setting in the DART <code class="docutils literal notranslate"><span class="pre">input.nml</span></code> file under
<em>obs_sequence_nml</em> called “write_binary_obs_sequence” that can be used
to write the format as either binary (“.true.”) or ASCII (“.false”).
When the observation sequence file is read, the format is detected
automatically.</p>
<p>For new obs converters, once you find what format the data is
distributed in you may be able to adapt one of the existing converters
here for your own use. Formats read by the existing converters include
netCDF, HDF, LITTLE_R, text, PREPBUFR, and many others. The section
<a class="reference external" href="#obsConverters">Observation converters provided by DART</a> lists the
converters that are already available for DART and the formats of the
files. The directory of the observation converters is
<code class="docutils literal notranslate"><span class="pre">DARTHOME/observations/obs_converters</span></code>.</p>
<p>If you have looked and none of the existing converters are right for
your data, here are some suggestions for where to start creating a new
converter. Create a new subdirectory in the <code class="docutils literal notranslate"><span class="pre">obs_converters</span></code>
directory. Copy with the recursive option (<code class="docutils literal notranslate"><span class="pre">cp</span> <span class="pre">-r</span></code>) one of the
existing converters and adapt to your needs. Our suggestions for which
converter to start from depends on the format of your input observations
to be converted. The following table lists our recommendations:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 52%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Native format</p></th>
<th class="head"><p>Advice</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>netCDF</p></td>
<td><p>Start with the MADIS
converters, and in particular
try the
<code class="docutils literal notranslate"><span class="pre">convert_madis_profiler.f90</span></code>
file because it is the most
straightforward. Another good
option is
<code class="docutils literal notranslate"><span class="pre">SST/oi_sst_to_obs.f90</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>Comma separated text</p></td>
<td><p>Start with the Ameriflux
converter.</p></td>
</tr>
<tr class="row-even"><td><p>ASCII text</p></td>
<td><p>Start with the text converter.</p></td>
</tr>
<tr class="row-odd"><td><p>HDF-EOS</p></td>
<td><p>Start with the AIRS converter.</p></td>
</tr>
<tr class="row-even"><td><p>BUFR or prepBUFR</p></td>
<td><p>Start with the NCEP converter.</p></td>
</tr>
<tr class="row-odd"><td><p>Dense data, like Satellite swaths</p></td>
<td><p>Start with the tpw converter,
which includes code that
averages the raw data in space
and time.</p></td>
</tr>
<tr class="row-even"><td><p>Ray-path integrated data</p></td>
<td><p>Start with the GPS converter,
which includes code that traces
a path and integrates values
along the ray.</p></td>
</tr>
<tr class="row-odd"><td><p>World Ocean Database packed ASCII</p></td>
<td><p>Start with the WOD converter.</p></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>` &lt;#DartForEducation&gt;`__</p>
</div>
</div>
<div class="section" id="how-would-i-use-dart-for-teaching-students-and-or-myself">
<h2>How would I use DART for teaching students and/or myself?<a class="headerlink" href="#how-would-i-use-dart-for-teaching-students-and-or-myself" title="Permalink to this headline">¶</a></h2>
<p>[<a class="reference external" href="#top">top</a>]</p>
<p>There are two main methods of learning DART beyond this document:</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="#dartTutorial">The DART tutorial</a></p></li>
<li><p><a class="reference external" href="#dartLab">DART_LAB</a></p></li>
</ol>
<p>` &lt;#dartTutorial&gt;`__</p>
<div class="section" id="the-dart-tutorial">
<h3>The DART tutorial<a class="headerlink" href="#the-dart-tutorial" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="Tutorial.md">DART Tutorial</a> outlines a step-by-step approach to
the concepts of ensemble data assimilation. A set of 26 PDF files guides
the user through a mathematical introduction to Data Assimilation and
Ensemble Kalman Filter concepts. If you’ve been able to build the Lorenz
63 model, you have correctly configured your <code class="docutils literal notranslate"><span class="pre">mkmf.template</span></code> and you
are now able to run all of the programs required by the tutorial.</p>
<p>` &lt;#dartLab&gt;`__</p>
</div>
<div class="section" id="dart-lab">
<h3>DART_LAB<a class="headerlink" href="#dart-lab" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="../DART_LAB/DART_LAB.html">DART_LAB</a> is a set of PDF presentation
files and a set of MATLAB® examples that comprise a fully self-contained
introduction to Data Assimilation and the Ensemble Kalman Filter
concepts. These documents are an excellent way to explore the
ins-and-outs of DART and learn about ensemble data assimilation.</p>
<hr class="docutils" />
<p>` &lt;#ContributeToDart&gt;`__</p>
</div>
</div>
<div class="section" id="how-can-i-contribute-to-dart">
<h2>How can I contribute to DART?<a class="headerlink" href="#how-can-i-contribute-to-dart" title="Permalink to this headline">¶</a></h2>
<p>[<a class="reference external" href="#top">top</a>]</p>
<p>In this section we describe how you can contribute your work to DART. As
an open-source project, we welcome and value your contributions for the
benefit of the community. You may want to get in touch with us at dart &#64;
ucar.edu before going too far down the development path and make sure
you are not duplicating efforts.</p>
<p>DART development uses the public GitHub project available at
<a class="reference external" href="https://github.com/NCAR/DART">https://github.com/NCAR/DART</a>. Before you get started on developing with
us, it’s probably a good idea to be familiar with the <a class="reference external" href="https://guides.github.com/introduction/flow/">GitHub
workflow</a>. Essentially,
you should create a <strong>fork</strong> of the DART project, which is a publically
visible copy of the repository that you will manage. Create a <strong>branch</strong>
for your feature with an appropriate name for your project, and when you
are finished with your changes you can <strong>commit</strong> them to your fork.
After testing locally on your machine, you can push them to your fork.
<em>At this point, everyone can see the changes you made on your fork.</em>
When you are ready to begin the conversation about merging your work
into the original project (called the DART repository master), you can
create a <strong>pull request</strong>, which will show your changes. After reviewing
and testing your changes, the pull request will be addressed
appropriately by the DART development team.</p>
<p>` &lt;#privateWorkflow&gt;`__</p>
<div class="section" id="what-if-i-want-my-work-to-remain-private-until-i-publish">
<h3>What if I want my work to remain private until I publish?<a class="headerlink" href="#what-if-i-want-my-work-to-remain-private-until-i-publish" title="Permalink to this headline">¶</a></h3>
<p>Some DART users want to work on a private branch until their work is
ready for public viewing. To accommodate users with these concerns, we
describe here an additional step to temporarily “hide” sensitive code
that is intended to be eventually contributed to DART after publication.</p>
<p>The user interested in maintaining this privacy should create a public
fork of the DART repository as listed above and then create a
<strong>private</strong> repository on GitHub.com, following the steps listed here:
<a class="reference external" href="https://help.github.com/en/articles/create-a-repo">https://help.github.com/en/articles/create-a-repo</a>. The name of this repo
is arbitrary. Now follow the steps at
<a class="reference external" href="https://help.github.com/en/articles/adding-a-remote">https://help.github.com/en/articles/adding-a-remote</a> to add the public
fork as a <em>remote</em> repository of the private repository. The remote name
here could be “public_fork” or “upstream.” Follow the usual steps for
pulling/pushing to/from your private repository as in
<a class="reference external" href="https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes">https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes</a></p>
<p>The user can then conduct their development on the private repository,
adding additional team members as necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">dart</dt>
<dd class="field-odd"><p><em>NOTE</em>: only 3 collaborators are allowed on a free</p>
</dd>
</dl>
<p>non-institutional private repository. The DART team is happy to
collaborate with you on your private repository, but keep the 3
collaborator limit in mind if you are a free GitHub.com user.</p>
<p>[<a class="reference external" href="#top">top</a>]</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, University Corporation for Atmospheric Research

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>